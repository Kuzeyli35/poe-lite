<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Diablo Lite v0.15</title>
    <style>
        :root {
            --bg: #7a7d82;
            --panel: #d6d7da;
            --ink: #222;
            --chip: #4b4d52;
            --chipInk: #eee;
            --blue: #3b82f6;
            --green: #22c55e;
            --red: #ef4444;
            --yellow: #fbbf24;
            --uniq: #f87171;
            --mag: #60a5fa;
            --norm: #9ca3af;
            --card-w: 180px;
            --card-h: 240px;
        }

        * {
            box-sizing: border-box;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial
        }

        html,
        body {
            margin: 0;
            background: var(--bg);
            color: #111;
            text-align: center;
            height: 100%;
            overflow: hidden;
        }

        body {
            overflow-y: auto;
        }

        button {
            cursor: pointer;
            border: none;
            border-radius: 12px;
            padding: 10px 18px;
            font-weight: 700;
            box-shadow: 0 2px 0 rgba(0, 0, 0, .25)
        }

        button:disabled {
            cursor: not-allowed;
            filter: grayscale(80%);
            opacity: 0.7;
        }

        .btn {
            background: var(--blue);
            color: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
            box-shadow: 0 2px 0 rgba(0, 0, 0, .25), inset 0 -2px 0 rgba(0, 0, 0, .25);
        }

        .hidden {
            display: none !important;
        }

        /* arena */
        #arenaScreen {
            padding: 18px;
            height: 100%;
            position: relative;
        }

        .topbar {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 6px;
            max-width: 1476px;
            margin: 0 auto 6px;
        }

        .chip {
            background: var(--chip);
            color: var(--chipInk);
            padding: 6px 12px;
            border-radius: 16px;
            box-shadow: inset 0 -3px 0 rgba(0, 0, 0, .15);
            font-weight: 800;
            font-size: 14px;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
        }

        .essence {
            font-weight: 900;
            padding: 6px 10px;
            background: #fff;
            border-radius: 10px;
            border: 1px solid #bbb
        }

        .arenaFrame {
            background: var(--panel);
            border-radius: 8px;
            box-shadow: 0 6px 0 rgba(0, 0, 0, .25), inset 0 0 0 2px #999;
            padding: 8px;
            position: relative;
            display: inline-block;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: transparent;
            border-radius: 4px;
            box-shadow: inset 0 0 0 2px #aaa;
            position: relative;
            z-index: 2;
        }

        .timerBox {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 8px;
            background: #666;
            color: #fff;
            padding: 8px 10px;
            border-radius: 10px;
            box-shadow: inset 0 -3px 0 rgba(0, 0, 0, .25);
            font-size: 16px;
            font-weight: 900;
            z-index: 3;
        }

        .timerBox.danger {
            background: #b91c1c;
            animation: pulse 1s infinite
        }

        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1) }
            50% { transform: translateX(-50%) scale(1.08) }
            100% { transform: translateX(-50%) scale(1) }
        }

        .pauseBadge {
            position: absolute;
            right: 14px;
            top: 6px;
            background: #111;
            color: #fff;
            padding: 4px 8px;
            border-radius: 8px;
            opacity: .8;
            display: none
        }

        .paused .pauseBadge {
            display: block
        }

        .chipRow {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: -36px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center
        }

        .xpBar {
            position: absolute;
            left: 200px;
            right: 200px;
            bottom: 12px;
            height: 22px;
            border-radius: 12px;
            background: #444;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: inset 0 -3px 0 rgba(0, 0, 0, .35);
            overflow: hidden;
            z-index: 3;
        }

        .xpFill {
            height: 100%;
            background: var(--green);
            width: 0%;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1
        }

        .xpBar span {
            position: relative;
            z-index: 2
        }
        
        #buffContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            opacity: 0.7;
            z-index: 10;
        }

        .buff-icon {
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            font-size: 16px;
            border: 2px solid #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .cooldown-icon {
            opacity: 0.4;
            filter: grayscale(100%);
        }

        /* build screen layout */
        #buildScreen {
            text-align: left;
            padding: 12px;
            height: 100%;
        }

        .grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            grid-template-rows: minmax(0, 1fr);
            gap: 12px;
            max-width: 1300px;
            margin: 0 auto;
            width: 100%;
            height: 100%;
        }

        .panel {
            background: #eee8;
            border-radius: 18px;
            box-shadow: 0 8px 0 rgba(0, 0, 0, .25), inset 0 0 0 2px #b2b2b2
        }
        
        /* ============== SIFIRDAN YAZILAN BÖLÜM BAŞLANGICI ============== */

        /* Panel artık esnek bir kolon (flex column). Bu, içindeki elemanları dikeyde dizer. */
        .grid > .panel:first-child {
            display: flex;
            flex-direction: column;
            min-width: calc(4 * var(--card-w) + 3 * 10px + 16px);
            /* overflow: hidden; -> Bu satırın olmaması kritik! */
        }
        
        .panel h2,
        .lootControls,
        .sortWrap {
            /* Bu elemanlar esnemez ve küçülmez, kendi doğal yüksekliklerinde kalırlar. */
            flex-shrink: 0;
        }
        
        .panel h2 {
            margin: 0;
            padding: 10px 14px;
            background: linear-gradient(#e5e7eb, #d1d5db);
            border-radius: 18px 18px 0 0;
            font-size: 22px;
            text-shadow: 0 2px #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .lootControls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
        }

        .lootControls .essence {
            margin-left: auto;
            font-size: 14px;
            padding: 4px 8px;
        }

        .lootControls button.pill {
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Bu, sihirli kısmın çalıştığı yer. */
        .lootWrap {
            flex-grow: 1; /* Üstteki elemanlardan sonra kalan TÜM dikey boşluğu doldurur. */
            overflow-y: auto; /* İçindeki içerik (lootGrid) bu alana sığmazsa, KAYDIRMA ÇUBUĞU gösterir. */
            min-height: 0; /* Flexbox'ın taşma ve kaydırma hesaplamalarını doğru yapmasını sağlayan kritik kural. */
            padding: 8px;
        }
        
        /* Scrollbar stilleri */
        .lootWrap::-webkit-scrollbar { width: 8px; }
        .lootWrap::-webkit-scrollbar-track { background: #00000022; border-radius: 4px; }
        .lootWrap::-webkit-scrollbar-thumb { background: var(--chip); border-radius: 4px; }
        .lootWrap::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Bu kuralda bir değişiklik yok, sadece içeriği scroll edilebilir alanın içinde kalacak. */
        .lootGrid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            align-content: start;
        }

        /* ============== SIFIRDAN YAZILAN BÖLÜM SONU ============== */


        .inv {
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(4, var(--card-w));
            gap: 10px;
            align-content: start;
            justify-content: center
        }

        .slot {
            background: #d1d5db;
            border-radius: 14px;
            padding: 0;
            width: var(--card-w);
            height: var(--card-h);
            position: relative;
            display: grid;
            place-items: center;
            text-align: center;
            border: 2px dashed #a3a3a3
        }

        .slot .placeholder {
            font-size: 24px;
            opacity: .5
        }

        .rightCol {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 12px;
        }

        .asideBtns {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            padding: 2px 0 12px
        }

        .nextWaveButtons {
            display: flex;
            gap: 10px;
        }

        .next {
            flex: 1;
            padding: 14px 12px;
            border-radius: 16px;
            background: #fff;
            box-shadow: 0 8px 0 rgba(0, 0, 0, .25);
            font-weight: 900
        }

        .next.btn-primary {
            background: var(--blue);
            color: #fff;
        }

        .sortWrap {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 0px 12px 8px 12px;
        }

        select,
        #sortLevel {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid #bbb;
            background: #fff;
            font-weight: 700
        }

        #sortLevel {
            width: 70px;
        }

        .ghost {
            opacity: .5
        }

        /* card */
        .icard {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 16px;
            background: #444;
            color: #fff;
            box-shadow: 0 6px 0 rgba(0, 0, 0, .25);
            position: relative;
            user-select: none;
            overflow: hidden;
            display: flex;
            flex-direction: column
        }

        .icard .ic-top {
            height: 44px;
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 16px 16px 0 0;
            gap: 4px;
        }

        .icard .ic-type {
            font-size: 18px;
            line-height: 1;
        }

        .icard .ic-level {
            font-family: Inter, sans-serif;
            font-size: 11px;
            font-weight: 900;
            background: var(--chip);
            color: var(--chipInk);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: auto;
        }

        .icard .ic-rar {
            font-weight: 900;
            padding: 3px 8px;
            border-radius: 999px;
            background: #222;
            color: #fff;
            font-size: 12px;
            box-shadow: inset 0 -2px 0 rgba(0, 0, 0, .35);
        }

        .icard .ic-lock {
            background: transparent;
            box-shadow: none;
            font-size: 18px;
            padding: 0 2px;
        }

        .icard .ic-name {
            font-weight: 900;
            text-align: center;
            padding: 8px 10px 4px;
            line-height: 1.1;
            font-size: 15px;
            word-wrap: break-word;
        }

        .icard .ic-sep {
            height: 2px;
            background: #fff6;
            margin: 6px 10px 4px;
            border-radius: 1px
        }

        .icard .ic-aff {
            font-size: 12px;
            line-height: 1.25;
            padding: 1px 10px;
            border-radius: 8px
        }

        .icard .ic-aff .val {
            font-weight: 900
        }

        .icard .ic-foot {
            margin-top: auto;
            height: 6px;
            background: #0002
        }

        .icard.locked { outline: 3px solid #fa1616; }
        .icard.sel { outline: 3px solid #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, .35) inset, 0 6px 0 rgba(0, 0, 0, .25) }
        .rarN { background: #3b3b40 }
        .rarM { background: #1f3d69 }
        .rarR { background: #6b5700 }
        .rarU { background: #6b1f1f }
        .rarN .ic-top { background: var(--norm); color: #222 }
        .rarM .ic-top { background: var(--mag) }
        .rarR .ic-top { background: var(--yellow); color: #222 }
        .rarU .ic-top { background: var(--uniq) }
        .icard .ic-aff.hl { background: #6fb6ff; color: #fff; box-shadow: 0 0 0 2px #dff1ff inset }
        .icard .ic-unique-aff {
            background: var(--uniq);
            color: #fff;
            font-weight: 700;
            font-size: 11px;
            line-height: 1.3;
            padding: 6px 10px;
            margin: 8px 10px 4px;
            border-radius: 8px;
            text-shadow: 0 1px 1px rgba(0,0,0,0.3);
        }
        
        /* modals */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50
        }

        .modal>div {
            background: #fff;
            border-radius: 14px;
            min-width: min(92vw, 560px);
            padding: 18px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, .35)
        }

        /* YENİ VE GÜNCELLENMİŞ .statList KURALI */
        .statList {
            padding: 10px 14px 14px;
            font-family: ui-monospace, Menlo, Consolas, monospace;
            font-size: 14px;
            
            /* YENİ EKLENEN ÖZELLİKLER */
            display: grid;                  /* Listeyi bir ızgara yapısına dönüştürür */
            grid-template-columns: 1fr 1fr; /* Izgarayı iki eşit sütuna böler */
            gap: 0 16px;                    /* Sütunlar arasına 16px boşluk ekler */
            
            flex-grow: 1;                   /* Panelin içinde kalan tüm dikey boşluğu doldurur */
            overflow-y: auto;               /* Eğer içerik yine de sığmazsa, kendi kaydırma çubuğunu gösterir */
            min-height: 0;                  /* Esnek (flex) yapılarda taşmayı önleyen kritik kural */
        }
        .rightCol .panel:nth-child(2) { /* Bu, sağ kolondaki ikinci paneli (yani Stats panelini) hedefler */
            display: flex;
            flex-direction: column;
        }

        .statList div { line-height: 1.4 }

        /* Notifications */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .notification {
            background: var(--red);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(100%);
            animation: slideInAndOut 4s ease-in-out;
        }

        @keyframes slideInAndOut {
            0% { opacity: 0; transform: translateX(100%); }
            10% { opacity: 1; transform: translateX(0); }
            90% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100%); }
        }
    </style>
</head>

<body>
    <div style="display:none;">
        <img id="backgroundTexture" src="C:\Users\ukuze\OneDrive\Masaüstü\diablo-lite-workspace\images\bg.jpg">
    </div>
    <section id="startScreen">
        <div class="start-content">
            <h2>Oyun Hakkında</h2>
            <p>
                Diablo/PoE Lite'a hoş geldin! Bu, hayatta kalma ve eşya toplama (loot) odaklı, hızlı tempolu bir arena savaş oyunudur. Amacın, giderek zorlaşan düşman dalgalarına (Wave) karşı ayakta kalmaktır.
            </p>
            <p>
                Her dalganın sonunda yeni ve daha güçlü eşyalar kazanacak, karakterini bu eşyalarla geliştirerek bir sonraki, daha çetin mücadeleye hazırlanacaksın. En iyi eşyaları topla, en güçlü karakteri yarat ve arenaların hakimi ol!
            </p>
            <div class="controls-grid">
                <div>
                    <h3>Arena Kontrolleri</h3>
                    <p><b>W, A, S, D:</b> Karakteri hareket ettirir.</p>
                    <p><b>Fare Hareketi:</b> Nişan almanı sağlar.</p>
                    <p><b>Farenin Sol Tuşu:</b> Ateş eder.</p>
                    <p><b>Boşluk (Space):</b> Işınlanma (Blink Boots varsa)</p>
                </div>
                <div>
                    <h3>Build Ekranı Kontrolleri</h3>
                    <p><b>Eşyaya Tıklama:</b> Seçer veya seçimini kaldırır.</p>
                    <p><b>Sürükle & Bırak:</b> Eşyayı envantere kuşanır.</p>
                    <p><b>Kilit Simgesi:</b> Eşyayı parçalanmaya karşı kilitler.</p>
                    <p><b>Upgrade/Dismantle:</b> Butonları kullanır.</p>
                </div>
            </div>
        </div>
        <div class="start-choice" style="display: flex; gap: 15px; justify-content: center;">
            <button class="btn" id="startWithGunBtn" style="background-color:#3b82f6;">Silahla Başla</button>
            <button class="btn" id="startWithSwordBtn" style="background-color:#8b5cf6;">Kılıçla Başla</button>
        </div>
    </section>

    <section id="arenaScreen" class="hidden">
        <div class="topbar">
            <div class="essence">Essence: <span id="essCount">0</span></div>
            <button id="pauseBtn" class="btn">Duraklat</button>
        </div>
        <div class="arenaFrame" id="arenaFrame">
            <div class="chipRow">
                <div class="chip">Wave: <span id="hudWave">1</span></div>
                <div class="chip">Kills: <span id="hudKill">0</span></div>
                <div class="chip">Total Kills: <span id="hudTotalKill">0</span></div>
                <div class="chip">Level: <span id="hudLevel">1</span></div>
            </div>
            <div class="timerBox" id="timerBox"><span id="timerLabel">45.00s</span></div>
            <div class="pauseBadge">PAUSED</div>
            <canvas id="game" width="1476" height="846"></canvas>
            <div class="xpBar">
                <div class="xpFill" id="xpFill"></div><span id="xpLabel"></span>
            </div>
            <div id="buffContainer" class="hidden"></div>
            <canvas id="minimap"></canvas>
        </div>
    </section>

    <section id="buildScreen" class="hidden">
        <div class="grid">
            <div class="panel">
                <h2>Loot</h2>
                <div class="lootControls">
                    <button class="pill" id="dismSel">Dismantle Selected</button>
                    <button class="pill" id="clearSel">Clear Selection</button>
                    <button class="pill btn-danger" id="dismAll">Dismantle All</button>
                    <div class="essence">Essence: <span id="essCountBuild">0</span></div>
                    <button class="pill" id="debugItemBtn" style="background-color:#8b5cf6;">+1 Unique Item (T1)</button>
                </div>
                <div class="sortWrap">
                    <strong>Sort</strong>
                    <label>By Type <select id="sortTypeSel"><option value="">All</option></select></label>
                    <label>By Stat <select id="sortStat"><option value="">-</option></select></label>
                    <label>By Level <input type="number" id="sortLevel" placeholder="Lvl"></label>
                </div>
                <div class="lootWrap">
                    <div class="lootGrid" id="lootGrid"></div>
                </div>
            </div>
            <div class="rightCol">
                <div class="panel">
                    <h2>Inventory <span class="chip" style="font-size:12px;">Player Level: <span id="buildPlayerLevel">1</span></span></h2>
                    <div class="inv" id="invGrid"></div>
                    <div class="asideBtns">
                        <button id="upgradeBtn" class="btn">Upgrade Selected</button>
                    </div>
                </div>
                <div class="panel">
                    <h2>Stats</h2>
                    <div class="statList" id="statPanel"></div>
                </div>
                <div class="nextWaveButtons">
                    <button class="next" id="sameWave">Same Wave</button>
                    <button class="next btn-primary" id="nextWave">Next Wave</button>
                </div>
            </div>
        </div>
    </section>

    <div class="modal hidden" id="levelModal">
        <div>
            <h3 style="margin:0 0 10px">Seviye atladın! Bir stat seç (Magic Find hariç)</h3>
            <div class="options" id="levelOptions" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px"></div>
        </div>
    </div>

    <div class="modal hidden" id="confirmModal">
        <div style="text-align:center">
            <h3 style="margin-top:0">Dismantle all unlocked items?</h3>
            <p>This cannot be undone.</p>
            <div style="display:flex;gap:10px;justify-content:center">
                <button id="confirmYes" class="btn">✔️ Yes</button>
                <button id="confirmNo" class="btn">❌ Cancel</button>
            </div>
        </div>
    </div>

    <div id="notification-container"></div>

    <script>
        /* Helpers */
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const rand = (a, b) => Math.random() * (b - a) + a;
        const randi = (a, b) => Math.floor(rand(a, b + 1));
        const choice = a => a[Math.floor(Math.random() * a.length)];
        const now = () => performance.now();
        const fmt = (n, d = 2) => Number.parseFloat(n).toFixed(d);
        let itemUIDCounter = 0;
        const uid = () => `item-${itemUIDCounter++}`;

        function weightedChoice(options) {
            let totalWeight = options.reduce((sum, opt) => sum + opt.weight, 0);
            if (totalWeight <= 0) {
                return choice(options.map(opt => opt.value));
            }
            let random = Math.random() * totalWeight;
            for (const opt of options) {
                if (random < opt.weight) return opt.value;
                random -= opt.weight;
            }
            return options[options.length - 1].value;
        }

        /* Constants */
        const STAT_KEYS = ["Physical Damage", "Damage %", "Fire Damage", "Lightning Damage", "Cold Damage", "Attack Speed", "Maximum Life", "Life Regen", "Armor", "Crit Chance", "Crit Damage", "Move Speed", "Magic Find"];
        const TYPE_KEYS = ["Gun", "Sword", "Helmet", "Chest", "Boots", "Belt", "Ring", "Gloves"];
        const SLOT_KEYS = ["Gun", "Helmet", "Chest", "Boots", "Belt", "Gloves", "Ring1", "Ring2"];
        const TYPE_EMOJI = { Gun: "🔫", Sword: "⚔️", Helmet: "👑", Chest: "🥻", Boots: "👞", Belt: "🩹", Ring: "💍", Gloves: "🧤" };
        const LOCK_EMOJI = { lock: "🔐", unlock: "🔓" };
        const RAR = { N: "NORMAL", M: "MAGICAL", R: "RARE", U: "UNIQUE" };
        const RAR_ORDER = ["N", "M", "R", "U"];
        const RAR_AFFIX = { N: 2, M: 3, R: 4, U: 5 };
        const RAR_ESSENCE = { N: 1, M: 3, R: 10, U: 30 };
        const UPGRADE_COST = { N: 3, M: 10, R: 30, U: 30 };
        const T_TIERS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        const AFFIX_RANGES = {
            "Physical Damage": { T1: [20, 25], T2: [17, 20], T3: [14, 17], T4: [12, 14], T5: [10, 12], T6: [8, 10], T7: [6, 8], T8: [4, 6], T9: [2, 4], T10: [1, 2], unit: "flat" },
            "Fire Damage": { T1: [15, 20], T2: [12, 15], T3: [10, 12], T4: [8, 10], T5: [6, 8], T6: [5, 6], T7: [4, 5], T8: [3, 4], T9: [2, 3], T10: [1, 2], unit: "flat" },
            "Lightning Damage": { T1: [10, 15], T2: [8, 12], T3: [7, 10], T4: [6, 8], T5: [5, 7], T6: [4, 6], T7: [3, 5], T8: [2, 4], T9: [1, 3], T10: [1, 2], unit: "flat" },
            "Cold Damage": { T1: [10, 15], T2: [8, 12], T3: [7, 10], T4: [6, 8], T5: [5, 7], T6: [4, 6], T7: [3, 5], T8: [2, 4], T9: [1, 3], T10: [1, 2], unit: "flat" },
            "Damage %": { T1: [18, 22], T2: [15, 18], T3: [12, 15], T4: [10, 12], T5: [8, 10], T6: [6, 8], T7: [4, 6], T8: [3, 4], T9: [2, 3], T10: [1, 2], unit: "pct" },
            "Attack Speed": { T1: [28, 35], T2: [24, 28], T3: [20, 24], T4: [17, 20], T5: [14, 17], T6: [11, 14], T7: [8, 11], T8: [5, 8], T9: [3, 5], T10: [1, 3], unit: "pct" },
            "Maximum Life": { T1: [35, 45], T2: [30, 35], T3: [25, 30], T4: [21, 25], T5: [17, 21], T6: [13, 17], T7: [9, 13], T8: [6, 9], T9: [4, 6], T10: [2, 4], unit: "flat" },
            "Life Regen": { T1: [2.0, 2.8], T2: [1.6, 2.0], T3: [1.2, 1.6], T4: [0.9, 1.2], T5: [0.6, 0.9], T6: [0.4, 0.6], T7: [0.3, 0.4], T8: [0.2, 0.3], T9: [0.1, 0.2], T10: [0.1, 0.1], unit: "flat" },
            "Armor": { T1: [20, 28], T2: [17, 20], T3: [14, 17], T4: [11, 14], T5: [8, 11], T6: [6, 8], T7: [4, 6], T8: [3, 4], T9: [2, 3], T10: [1, 2], unit: "flat" },
            "Crit Chance": { T1: [8, 10], T2: [7, 8], T3: [6, 7], T4: [5, 6], T5: [4, 5], T6: [3, 4], T7: [2.5, 3], T8: [2, 2.5], T9: [1, 2], T10: [0.5, 1], unit: "pct" },
            "Crit Damage": { T1: [70, 85], T2: [60, 70], T3: [50, 60], T4: [40, 50], T5: [30, 40], T6: [22, 30], T7: [15, 22], T8: [10, 15], T9: [6, 10], T10: [3, 6], unit: "pct" },
            "Move Speed": { T1: [15, 20], T2: [12, 15], T3: [10, 12], T4: [8, 10], T5: [6, 8], T6: [5, 6], T7: [4, 5], T8: [3, 4], T9: [2, 3], T10: [1, 2], unit: "pct" },
            "Magic Find": { T1: [25, 35], T2: [20, 25], T3: [16, 20], T4: [13, 16], T5: [10, 13], T6: [8, 10], T7: [6, 8], T8: [4, 6], T9: [2, 4], T10: [1, 2], unit: "pct" },
        };
        const LEVEL_UP_CHOICES = [{
            k: "Physical Damage", apply: p => { p.base.damage += 2 }, label: "+2 Physical Damage"
        }, {
            k: "Attack Speed", apply: p => { p.base.attackSpeed *= 1.05 }, label: "+%5 Attack Speed"
        }, {
            k: "Maximum Life", apply: p => { p.base.maxLife += 5; p.life = Math.min(p.life + 5, p.base.maxLife) }, label: "+5 Maximum Life"
        }, {
            k: "Life Regen", apply: p => { p.base.lifeRegen += 0.5 }, label: "+0.5 Life Regen"
        }, {
            k: "Armor", apply: p => { p.base.armor += 2 }, label: "+2 Armor"
        }, {
            k: "Crit Chance", apply: p => { p.base.critChance += 1 }, label: "+1% Crit Chance"
        }, {
            k: "Crit Damage", apply: p => { p.base.critDamage += 10 }, label: "+10% Crit Damage"
        }, {
            k: "Move Speed", apply: p => { p.base.moveSpeed *= 1.03 }, label: "+%3 Move Speed"
        }, ];
        const LEVEL_XP_MULTIPLIER = 1.4;
        const WAVE_XP_MULTIPLIER = 0.25;
        const WAVE_SCALE = wave => ({
            hpMul: 1 + 0.15 * (wave - 1), dmgMul: 1 + 0.12 * (wave - 1),
            spdMul: 1 + 0.04 * (wave - 1), spawnMul: 1 + 0.06 * (wave - 1)
        });
        const BASE_DROP = 0.03;
        const MAGIC_CHANCE_BASE = 0.08;
        const MAGIC_CHANCE_WAVE_SCALE = 0.0025;
        const RARE_CHANCE_BASE = 0.01;
        const RARE_CHANCE_WAVE_SCALE = 0.0015;
        const PACK_STRUCTURES = { Normal: [ { size: 2, weight: 40 }, { size: 3, weight: 30 }, { size: 4, weight: 15 }, { size: 5, weight: 8 }, { size: 6, weight: 4 }, { size: 7, weight: 2 }, { size: 8, weight: 1 } ], Magic: [ { size: 2, weight: 60 }, { size: 3, weight: 30 }, { size: 4, weight: 10 } ], Rare: [ { size: 1, weight: 85 }, { size: 2, weight: 15 } ] };
        const UNIQUE_ITEMS = { Gun: [{ name: "Apocalypse Carrier", uniqueId: "UNIQUE_GUN_SHOTGUN", affixes: [{ stat: "Damage %", T1: [25, 30], T10: [5, 8] }, { stat: "Crit Chance", T1: [8, 10], T10: [1, 2] }, ], uniqueProps: { bulletCount: 5, spreadAngle: 25, damageModifier: { T1: 0.50, T10: 0.35 } } }, { name: "Soul Piercer", uniqueId: "UNIQUE_GUN_PIERCE", affixes: [{ stat: "Crit Damage", T1: [70, 85], T10: [15, 25] }, { stat: "Physical Damage", T1: [20, 25], T10: [4, 8] }, ], uniqueProps: { pierce: true, attackSpeedModifier: { T1: -0.15, T10: -0.30 }, bulletSpeedMultiplier: 1.75, bulletRangeMultiplier: 2.5 } }], Helmet: [{ name: "Headpiece of Frenzy", uniqueId: "UNIQUE_HELMET_FRENZY", affixes: [{ stat: "Move Speed", T1: [15, 20], T10: [3, 5] }, { stat: "Armor", T1: [20, 25], T10: [5, 8] }, ], uniqueProps: { maxStacks: 4, duration: 2.0, moveSpeedPerStack: { T1: 0.10, T10: 0.01 } } }, { name: "Crown of the Fountain of Life", uniqueId: "UNIQUE_HELMET_LIFE_FOUNTAIN", affixes: [{ stat: "Maximum Life", T1: [35, 45], T10: [8, 12] }, { stat: "Life Regen", T1: [2.5, 3.5], T10: [0.5, 0.8] }, ], uniqueProps: { armorReduction: 0.20, lifeRegenMultiplier: { T1: 10, T10: 2 } } }], Chest: [{ name: "Platemail of the Guardian", uniqueId: "UNIQUE_CHEST_GUARDIAN", affixes: [{ stat: "Armor", T1: [30, 40], T10: [10, 15] }, { stat: "Maximum Life", T1: [30, 40], T10: [10, 15] }, ], uniqueProps: { threshold: 0.20, damageReduction: { T1: 0.50, T10: 0.30 }, duration: { T1: 6, T10: 2 }, cooldown: { T1: 3, T10: 10 } } }, { name: "Thornmail", uniqueId: "UNIQUE_CHEST_THORNS", affixes: [{ stat: "Armor", T1: [25, 30], T10: [8, 12] }, { stat: "Life Regen", T1: [1.5, 2.0], T10: [0.3, 0.5] }, ], uniqueProps: { reflectPercentage: { T1: 0.50, T10: 0.05 } } }], Boots: [{ name: "Storm Runners", uniqueId: "UNIQUE_BOOTS_ICETRAIL", affixes: [{ stat: "Move Speed", T1: [25, 30], T10: [8, 12] }, { stat: "Attack Speed", T1: [10, 15], T10: [2, 4] }, ], uniqueProps: { duration: { T1: 3, T10: 1.5 }, slowPercentage: { T1: 0.60, T10: 0.30 } } }, { name: "Blink Boots", uniqueId: "UNIQUE_BOOTS_BLINK", affixes: [{ stat: "Move Speed", T1: [20, 25], T10: [5, 8] }, { stat: "Magic Find", T1: [20, 25], T10: [5, 8] }, ], uniqueProps: { distance: 300, cooldown: { T1: 3.5, T10: 15 } } }], Belt: [{ name: "Juggernaut's Clasp", uniqueId: "UNIQUE_BELT_JUGGERNAUT", affixes: [{ stat: "Maximum Life", T1: [40, 50], T10: [10, 15] }, { stat: "Armor", T1: [25, 30], T10: [8, 12] }, ], uniqueProps: { maxStacks: 10, interval: 2.0, armorPerStack: { T1: 0.05, T10: 0.015 }, regenPerStack: { T1: 1, T10: 0.2 } } }, { name: "Sash of a Thousand Stings", uniqueId: "UNIQUE_BELT_NOVABLAST", affixes: [{ stat: "Attack Speed", T1: [12, 18], T10: [3, 5] }, { stat: "Physical Damage", T1: [15, 20], T10: [3, 6] }, ], uniqueProps: { hitsRequired: 5, projectileCount: 10, resetTime: 3.0, damageMultiplier: { T1: 1.0, T10: 0.25 } } }], Ring: [{ name: "Band of Greed", uniqueId: "UNIQUE_RING_GREED", affixes: [{ stat: "Magic Find", T1: [30, 40], T10: [10, 15] }, { stat: "Move Speed", T1: [8, 10], T10: [2, 3] }, ], uniqueProps: { duration: { T1: 10, T10: 4 }, magicFindBonus: { T1: 2.00, T10: 0.50 } } }, { name: "Seal of Criticality", uniqueId: "UNIQUE_RING_CRITICALITY", affixes: [{ stat: "Crit Damage", T1: [80, 100], T10: [20, 30] }, { stat: "Crit Chance", T1: [15, 24], T10: [3, 6] }, ], uniqueProps: { critMultiplier: 1.5, nonCritPenalty: { T1: 0.90, T10: 0.60 } } }] };
        const interpolateByTier = (tier, t1Value, t10Value) => { return t10Value + (t1Value - t10Value) * ((10 - (tier - 1)) / 9); };
        const UNIQUE_DESCRIPTIONS = { 'UNIQUE_GUN_SHOTGUN': (props) => `Mermiler 5'e ayrılır. Her biri normal hasarın %${(props.damageModifier.value * 100).toFixed(0)} kadarını verir (T${props.damageModifier.tier}).`, 'UNIQUE_GUN_PIERCE': (props) => `Mermiler düşmanların içinden geçer, %75 daha hızlı uçar ve menzilleri %150 daha fazladır. %${(Math.abs(props.attackSpeedModifier.value) * 100).toFixed(0)} daha az Saldırı Hızı (T${props.attackSpeedModifier.tier}).`, 'UNIQUE_HELMET_FRENZY': (props) => `Öldürme başına 2s için +%${(props.moveSpeedPerStack.value * 100).toFixed(0)} Hareket Hızı kazandırır (En fazla 4 yük) (T${props.moveSpeedPerStack.tier}).`, 'UNIQUE_HELMET_LIFE_FOUNTAIN': (props) => `Can Yenilenmeni ${props.lifeRegenMultiplier.value.toFixed(1)} kat artırır (T${props.lifeRegenMultiplier.tier}), ancak Zırhını %20 azaltır.`, 'UNIQUE_CHEST_GUARDIAN': (props) => `Büyük darbede ${props.duration.value.toFixed(1)}s için %${(props.damageReduction.value*100).toFixed(0)} koruma (T${props.duration.tier}). Bekleme Süresi: ${props.cooldown.value.toFixed(1)}s (T${props.cooldown.tier}).`, 'UNIQUE_CHEST_THORNS': (props) => `Yakın dövüş hasarının %${(props.reflectPercentage.value*100).toFixed(0)} kadarını düşmana yansıtır (T${props.reflectPercentage.tier}).`, 'UNIQUE_BOOTS_ICETRAIL': (props) => `Hareket ederken arkanda ${props.duration.value.toFixed(1)}s kalan ve düşmanları %${(props.slowPercentage.value*100).toFixed(0)} yavaşlatan bir buz izi bırakırsın (T${props.duration.tier}).`, 'UNIQUE_BOOTS_BLINK': (props) => `İmlece doğru ışınlanmanı sağlayan bir yetenek kazanırsın. Bekleme Süresi: ${props.cooldown.value.toFixed(1)}s (T${props.cooldown.tier}).`, 'UNIQUE_BELT_JUGGERNAUT': (props) => `2s hareketsiz kalınca 1 "Juggernaut" yükü kazanırsın (maks 10). Her yük +%${(props.armorPerStack.value*100).toFixed(1)} Zırh (T${props.armorPerStack.tier}) ve +${props.regenPerStack.value.toFixed(1)} Can Yenilemesi (T${props.regenPerStack.tier}) verir. Hareket edince tüm yükler sıfırlanır.`, 'UNIQUE_BELT_NOVABLAST': (props) => `Her 5. isabetin (3s içinde) "Nova Blast" tetikler ve etrafa 10 mermi yollar. Mermiler silah hasarının %${(props.damageMultiplier.value*100).toFixed(0)} kadarını verir (T${props.damageMultiplier.tier}).`, 'UNIQUE_RING_GREED': (props) => `Nadir bir düşman öldürdüğünde ${props.duration.value.toFixed(1)}s (T${props.duration.tier}) için +%${(props.magicFindBonus.value*100).toFixed(0)} Magic Find (T${props.magicFindBonus.tier}) kazanırsın.`, 'UNIQUE_RING_CRITICALITY': (props) => `Kritik vuruşların %50 daha fazla hasar verir, ancak kritik olmayan vuruşların %${((1-props.nonCritPenalty.value)*100).toFixed(0)} daha az hasar verir (T${props.nonCritPenalty.tier}).` };

        /* Item */
        class Item {
            constructor({ type, rarity, name, affixes, id, ilvl }) {
                this.id = id || uid();
                this.type = type; this.rarity = rarity; this.ilvl = ilvl;
                this.uniqueId = null; this.uniqueProps = null;
                this.affixes = affixes || Item.rollAffixes.call(this, rarity, ilvl, type);
                this.name = name || (this.name ? this.name : ItemNameGen.random(type, rarity));
                this.locked = false; this.selected = false;
            }
            static getWeightedTiers(ilvl) {
                return T_TIERS.map(tier => {
                    const targetTier = clamp(11 - Math.floor(ilvl / 9), 1, 10);
                    const distance = Math.abs(targetTier - tier);
                    const weight = 1 / Math.pow(distance + 1.5, 3);
                    return { value: tier, weight: weight };
                });
            }
            static rollAffixes(r, ilvl = 1, type = null) {
                const forceT1 = (ilvl === -1);
                const weights = Item.getWeightedTiers(forceT1 ? 1 : ilvl);
                if (r === 'U' && type && UNIQUE_ITEMS[type]) {
                    const uniquePool = UNIQUE_ITEMS[type];
                    const chosenUnique = choice(uniquePool);
                    const aff = [];
                    for (const uniqueAffix of chosenUnique.affixes) {
                        const tier = forceT1 ? 1 : weightedChoice(weights);
                        const t1Range = uniqueAffix.T1; const t10Range = uniqueAffix.T10;
                        const minVal = interpolateByTier(tier, t1Range[0], t10Range[0]);
                        const maxVal = interpolateByTier(tier, t1Range[1], t10Range[1]);
                        aff.push({ stat: uniqueAffix.stat, tier: tier, value: rand(minVal, maxVal) });
                    }
                    this.uniqueId = chosenUnique.uniqueId;
                    this.name = chosenUnique.name;
                    this.uniqueProps = {};
                    for (const key in chosenUnique.uniqueProps) {
                        const prop = chosenUnique.uniqueProps[key];
                        if (typeof prop === 'object' && prop.T1 !== undefined) {
                            const tier = forceT1 ? 1 : weightedChoice(weights);
                            this.uniqueProps[key] = { value: interpolateByTier(tier, prop.T1, prop.T10), tier: tier };
                        } else {
                            this.uniqueProps[key] = { value: prop, tier: null };
                        }
                    }
                    return aff;
                }
                const c = RAR_AFFIX[r];
                const used = new Set();
                const aff = [];
                for (let i = 0; i < c; i++) {
                    let s; let tries = 0;
                    do { s = choice(STAT_KEYS); tries++; } while (used.has(s) && tries < 20);
                    used.add(s);
                    const t = weightedChoice(weights);
                    const range = AFFIX_RANGES[s]["T" + t];
                    aff.push({ stat: s, tier: t, value: rand(range[0], range[1]) });
                }
                return aff;
            }
            essenceYield() { return RAR_ESSENCE[this.rarity] }
            upgrade() {
                if (this.rarity === 'U') { UI.showNotification("Unique items cannot be upgraded!"); Game.player.essence += UPGRADE_COST[this.rarity]; return; }
                const i = RAR_ORDER.indexOf(this.rarity);
                if (i < RAR_ORDER.length - 1) {
                    const nextRarity = RAR_ORDER[i + 1];
                    if (nextRarity === 'U') { const newAffixes = Item.rollAffixes.call(this, 'U', this.ilvl, this.type); this.affixes = newAffixes; } 
                    else {
                        this.rarity = nextRarity;
                        let s; const used = new Set(this.affixes.map(a => a.stat)); let tries = 0;
                        do { s = choice(STAT_KEYS); tries++; } while (used.has(s) && tries < 20);
                        const weights = Item.getWeightedTiers(this.ilvl); const t = weightedChoice(weights);
                        const range = AFFIX_RANGES[s]["T" + t];
                        this.affixes.push({ stat: s, tier: t, value: rand(range[0], range[1]) });
                    }
                    this.rarity = nextRarity;
                }
            }
            static affixHTML(a) {
                const unit = AFFIX_RANGES[a.stat].unit;
                const val = unit === "pct" ? `${fmt(a.value)}%` : `${fmt(a.value)}`;
                return `<div class="ic-aff" data-stat="${a.stat}">${a.stat} <span class="val">+${val}</span> (T${a.tier})</div>`;
            }
            toHTML(context = "loot") {
                const c = document.createElement("div");
                c.className = "icard rar" + this.rarity; c.draggable = true;
                c.dataset.id = this.id; c.dataset.ctx = context;
                const rarText = RAR[this.rarity], emoji = TYPE_EMOJI[this.type] || "🞄";
                let bodyHTML = this.affixes.map(a => Item.affixHTML(a)).join("");
                if (this.uniqueId && UNIQUE_DESCRIPTIONS[this.uniqueId]) { const uniqueDesc = UNIQUE_DESCRIPTIONS[this.uniqueId](this.uniqueProps); bodyHTML += `<div class="ic-unique-aff">${uniqueDesc}</div>`; }
                c.innerHTML = `<div class="ic-top"><div class="ic-type">${emoji}</div><div class="ic-level">Lvl: ${this.ilvl}</div><div class="ic-rar">${rarText}</div><button class="ic-lock" title="lock/unlock">${this.locked?LOCK_EMOJI.lock:LOCK_EMOJI.unlock}</button></div><div class="ic-name">${this.name}</div><div class="ic-sep"></div><div class="ic-body" style="flex:1;display:block;overflow:auto">${bodyHTML}</div><div class="ic-foot"></div>`;
                c.querySelector(".ic-lock").onclick = e => { e.stopPropagation(); this.locked = !this.locked; UI.renderLoot(); UI.renderInventory(); };
                c.addEventListener("click", () => {
                    if (context === "inventory") {
                        for (const it of Game.player.loot) it.selected = false;
                        let wasSelected = this.selected;
                        for (const k of Object.keys(Game.player.inv)) { const it = Game.player.inv[k]; if (it) it.selected = false; }
                        this.selected = !wasSelected;
                    } else {
                        for (const k of Object.keys(Game.player.inv)) { const it = Game.player.inv[k]; if (it) it.selected = false; }
                        this.selected = !this.selected;
                    }
                    UI.renderLoot(); UI.renderInventory();
                });
                c.addEventListener("dragstart", e => { e.dataTransfer.setData("text/plain", JSON.stringify({ kind: "item", id: this.id })); c.classList.add("ghost"); });
                c.addEventListener("dragend", () => c.classList.remove("ghost"));
                c.querySelectorAll(".ic-aff").forEach(el => { el.addEventListener("mouseenter", () => UI.setHoverStat(el.dataset.stat)); el.addEventListener("mouseleave", () => UI.setHoverStat("")); });
                if (this.selected) c.classList.add("sel");
                if (this.locked) c.classList.add("locked");
                return c;
            }
        }
        const ItemNameGen = { prefix: { N: ["Rusty", "Broken", "Old", "Simple", "Worn", "Decayed"], M: ["Magic", "Glowing", "Arcane", "Mystic", "Adept's", "Apprentice's"], R: ["Grand", "Dire", "Masterwork", "Savage", "Vicious", "Cruel"], U: ["Divine", "Godly", "Cosmic", "Relic", "Storm's", "Emperor's"] }, suffix: { N: ["", "of Agony", "of Pain", "of Harm"], M: ["of Sorcery", "of the Apprentice", "of Sparks", "of Haste"], R: ["of the Titan", "of the Assassin", "of the Guardian", "of Carnage"], U: ["of Apocalypse", "of Ancient Kings", "of the Void", "Legacy"] }, noun: { Gun: ["Pistol", "Handgun", "Revolver", "Flintlock"], Sword: ["Blade", "Kılıç", "Longsword", "Scimitar", "Katana"], Helmet: ["Helm", "Crown", "Cap", "Headguard"], Chest: ["Plate", "Armor", "Mail", "Vestment"], Boots: ["Shoes", "Greaves", "Boots", "Sabatons"], Belt: ["Belt", "Strap", "Girdle", "Sash"], Ring: ["Ring", "Loop", "Band", "Seal"], Gloves: ["Gloves", "Gauntlets", "Handguards", "Mitts"] }, random(type, rar) { const p = choice(this.prefix[rar] || this.prefix.N); const n = choice(this.noun[type] || ["Thing"]); if (rar === 'N' && Math.random() < 0.6) return `${p} ${n}`; const s = choice(this.suffix[rar] || this.suffix.N); let name = `${p} ${n} ${s}`; if (name.length > 20 && n.length > 6) name = `${p} ${n}`; return name.trim(); } };

        /* Player */
        class Player {
            constructor(x, y) {
                this.x = x; this.y = y; this.r = 16;
                this.dir = { x: 1, y: 0 };
                this.moveDir = { x: 1, y: 0 };
                this.base = { damage: 8, attackSpeed: 2.2, maxLife: 25, lifeRegen: 0.0, armor: 5, critChance: 3, critDamage: 124, moveSpeed: 150, magicFind: 1 };
                this.life = this.base.maxLife;
                this.level = 1; this.kill = 0; this.totalKills = 0; this.wave = 0; this.xp = 0; this.xpNext = 100;
                this.inv = { Gun: null, Helmet: null, Chest: null, Boots: null, Belt: null, Gloves: null, Ring1: null, Ring2: null };
                this.loot = []; this.essence = 0; this.cooldown = 0;
                this.swordAttackDirection = 1;
                this.canCombo = false;
                this.frenzyStacks = 0; this.frenzyTimer = 0;
                this.guardianShieldActive = false; this.guardianShieldTimer = 0; this.guardianShieldCooldown = 0;
                this.guardianShieldColor = "#a78bfa";
                this.stormRunnerTrailCd = 0; this.blinkCooldown = 0;
                this.juggernautStacks = 0; this.timeStationary = 0;
                this.novaHitCounter = 0; this.novaHitTimer = 0;
                this.greedBuffTimer = 0;
            }
            derived() {
                const sum = { flat: {}, pct: {} };
                const add = (k, v, u) => {
                    if (u === "pct") { sum.pct[k] = (sum.pct[k] || 0) + v; } 
                    else { sum.flat[k] = (sum.flat[k] || 0) + v; }
                };
                for (const t of SLOT_KEYS) {
                    const it = this.inv[t];
                    if (!it) continue;
                    for (const a of it.affixes) { const u = AFFIX_RANGES[a.stat].unit; add(a.stat, a.value, u); }
                }
                const s = {
                    physicalDamage: (this.base.damage + (sum.flat["Physical Damage"] || 0)) * (1 + (sum.pct["Damage %"] || 0) / 100),
                    fireDamage: sum.flat["Fire Damage"] || 0,
                    lightningDamage: sum.flat["Lightning Damage"] || 0,
                    coldDamage: sum.flat["Cold Damage"] || 0,
                    attackSpeed: this.base.attackSpeed * (1 + (sum.pct["Attack Speed"] || 0) / 100),
                    maxLife: this.base.maxLife + (sum.flat["Maximum Life"] || 0),
                    lifeRegen: this.base.lifeRegen + (sum.flat["Life Regen"] || 0),
                    armor: this.base.armor + (sum.flat["Armor"] || 0),
                    critChance: this.base.critChance + (sum.pct["Crit Chance"] || 0),
                    critDamage: this.base.critDamage + (sum.pct["Crit Damage"] || 0),
                    moveSpeed: this.base.moveSpeed * (1 + (sum.pct["Move Speed"] || 0) / 100),
                    magicFind: this.base.magicFind + (sum.pct["Magic Find"] || 0)
                };
                const equippedGun = this.inv.Gun;
                if (equippedGun && equippedGun.uniqueId === 'UNIQUE_GUN_PIERCE') { s.attackSpeed *= (1 + equippedGun.uniqueProps.attackSpeedModifier.value); }
                const equippedHelmet = this.inv.Helmet;
                if (equippedHelmet) { if (equippedHelmet.uniqueId === 'UNIQUE_HELMET_FRENZY' && this.frenzyStacks > 0) { s.moveSpeed *= (1 + this.frenzyStacks * equippedHelmet.uniqueProps.moveSpeedPerStack.value); } if (equippedHelmet.uniqueId === 'UNIQUE_HELMET_LIFE_FOUNTAIN') { s.lifeRegen *= equippedHelmet.uniqueProps.lifeRegenMultiplier.value; s.armor *= (1 - equippedHelmet.uniqueProps.armorReduction.value); } }
                const equippedBelt = this.inv.Belt;
                if (equippedBelt) { if (equippedBelt.uniqueId === 'UNIQUE_BELT_JUGGERNAUT' && this.juggernautStacks > 0) { s.armor *= (1 + this.juggernautStacks * equippedBelt.uniqueProps.armorPerStack.value); s.lifeRegen += this.juggernautStacks * equippedBelt.uniqueProps.regenPerStack.value; } }
                const equippedRing = this.inv.Ring;
                if (equippedRing) { if (equippedRing.uniqueId === 'UNIQUE_RING_GREED' && this.greedBuffTimer > 0) { const props = equippedRing.uniqueProps; s.magicFind *= (1 + props.magicFindBonus.value); } }
                this.life = Math.min(this.life, s.maxLife);
                return s;
            }
            dps() { const s = this.derived(); const c = 1 + (s.critChance / 100) * (s.critDamage / 100 - 1); return (s.physicalDamage + s.fireDamage + s.lightningDamage + s.coldDamage) * s.attackSpeed * c; }
            gainXP(n) { Game.currentWaveXp += n; this.xp += n; if (this.xp >= this.xpNext) { this.xp -= this.xpNext; this.level++; this.xpNext = Math.floor(this.xpNext * LEVEL_XP_MULTIPLIER); UI.updateHUD(); Game.pause(true); UI.showLevelUp(); } UI.updateXP(); }
            takeDamage(a) { const s = this.derived(); let incomingDamage = a; const equippedChest = this.inv.Chest; if (this.guardianShieldActive && equippedChest && equippedChest.uniqueId === 'UNIQUE_CHEST_GUARDIAN') { incomingDamage *= (1 - equippedChest.uniqueProps.damageReduction.value); } const mitig = incomingDamage * (100 / (100 + s.armor)); if (equippedChest && equippedChest.uniqueId === 'UNIQUE_CHEST_GUARDIAN' && !this.guardianShieldActive && this.guardianShieldCooldown <= 0) { if (mitig > s.maxLife * equippedChest.uniqueProps.threshold.value) { this.guardianShieldActive = true; this.guardianShieldTimer = equippedChest.uniqueProps.duration.value; UI.updateBuffs(); } } this.life -= mitig; if (this.life < 0) this.life = 0; }
            heal(a) { const s = this.derived(); this.life = Math.min(s.maxLife, this.life + a); }
        }

        /* Enemy */
        class Enemy {
            constructor(x, y, wave, type = "grunt", rarity = "Normal", stunOverride = null) {
                this.id = uid();
                const sc = WAVE_SCALE(wave);
                this.x = x; this.y = y; this.type = type; this.rarity = rarity;
                let baseHp = 12, baseDmg = 6, baseSpd = 80, baseXp = 0; this.r = 14; this.blessedBy = null; this.actionCD = rand(0.5, 1.5);
                switch (type) { case 'brute': this.r *= 1.12; this.shape = 'hexagon'; baseXp = 5; baseHp *= 2; baseDmg *= 1.5; baseSpd *= 0.75; break; case 'slime': this.r *= 2; this.shape = 'circle'; this.color = '#84cc16'; baseXp = 7; baseHp *= 4; baseSpd *= 0.25; break; case 'rusher': this.r *= 0.5; this.shape = 'circle'; this.color = '#f59e0b'; baseXp = 2; baseHp *= 0.5; baseSpd *= 1.5; break; case 'watcher': this.shape = 'circle'; baseXp = 4; baseHp *= 1; baseDmg *= 1; baseSpd *= 0.8; this.attackRange = 400; break; case 'shaman': this.r = 15; this.shape = 'pentagon'; baseXp = 4; baseHp *= 1.2; baseDmg = 0; baseSpd *= 0.66; this.attackRange = 550; this.isCasting = false; this.castTime = 0; break; case 'bomber': this.r = 12; this.shape = 'circle'; baseXp = 7; baseHp *= 0.5; baseDmg = baseDmg * 2.5; baseSpd *= 1.4; break; case 'grunt': default: this.shape = 'circle'; baseXp = 3.5; break; }
                if (type !== 'slime' && type !== 'rusher') { this.color = choice(["#ef4444", "#f59e0b", "#10b981", "#60a5fa", "#eab308"]); }
                this.xp = baseXp * (1 + (wave - 1) * WAVE_XP_MULTIPLIER);
                if (this.rarity === 'Magic' || this.rarity === 'Rare') {
                    const buffPool = ['hp', 'dmg', 'spd', 'size']; buffPool.sort(() => 0.5 - Math.random());
                    let buffCount = 0; let buffMultiplier = 1.0;
                    if(this.rarity === 'Magic') { buffCount = 2; buffMultiplier = 1.3; } else if (this.rarity === 'Rare') { buffCount = 3; buffMultiplier = 1.6; }
                    const buffsToApply = buffPool.slice(0, buffCount);
                    for (const buff of buffsToApply) { if (buff === 'hp') baseHp *= buffMultiplier; if (buff === 'dmg') baseDmg *= buffMultiplier; if (buff === 'spd') baseSpd *= buffMultiplier; if (buff === 'size') this.r *= buffMultiplier; }
                    if (this.rarity === 'Magic') this.xp *= 2;
                    if (this.rarity === 'Rare') this.xp *= 4;
                    if (Math.random() < 0.5) { this.blessedBy = 'self'; }
                }
                this.maxLife = baseHp * sc.hpMul; this.life = this.maxLife; this.damage = baseDmg * sc.dmgMul; this.speed = baseSpd * sc.spdMul;
                this.hitCD = 0; this.stunCD = 0; this.showHP = false; this.spawnStunTimer = stunOverride !== null ? stunOverride : 1.5;
                this.debuffs = { burning: { isActive: false, damagePerSecond: 0, duration: 0, nextTick: 0 }, chill: { stacks: 0, lastHitTime: 0 }, frozen: { isActive: false, duration: 0, armorReduction: 0.3 } };
            }
        }

        /* Game */
        const Game = {
            canvas: null, ctx: null, w: 1476, h: 846, worldW: 1476 * 2, worldH: 846 * 2,
            camX: 0, camY: 0, minimap: null, minimapCtx: null, frame: null, paused: false,
            player: null, bullets: [], enemyBullets: [], silhouettes: [], swingEffect: null,
            slashEffects: [], swingAngle: 0, swordStartAngleOffset: 0, groundEffects: [], visualEffects: [],
            lastTime: 0, time: 0, timer: 45.0, spawnClock: 0, floaters: [], state: "start",
            currentWaveXp: 0, justDied: false, backgroundPattern: null,
            init() {
                this.canvas = document.getElementById("game"); this.ctx = this.canvas.getContext("2d"); this.frame = document.getElementById("arenaFrame");
                this.minimap = document.getElementById("minimap"); this.minimapCtx = this.minimap.getContext("2d");
                this.player = new Player(this.w / 2, this.h / 2);
                UI.populateSortOptions(); UI.renderInventory(); UI.renderStats(); this.bindControls(); UI.syncEssence();
                const bgImage = document.getElementById('backgroundTexture');
                bgImage.onload = () => { this.backgroundPattern = this.ctx.createPattern(bgImage, 'repeat'); };
                if (bgImage.complete) { bgImage.onload(); }
            },
            startArena(isSameWave = false) {
                this.justDied = false;
                if (this.player.wave === 0) isSameWave = false;
                if (!isSameWave) { this.player.wave++; if (this.player.wave > 1) { this.player.heal(this.player.derived().maxLife * 0.25); } }
                this.currentWaveXp = 0; this.state = "arena"; this.timer = 60.0;
                this.enemies = []; this.bullets = []; this.enemyBullets = []; this.groundEffects = []; this.floaters = []; this.visualEffects = [];
                this.player.kill = 0; this.player.x = this.worldW / 2; this.player.y = this.worldH / 2;
                document.getElementById("startScreen").classList.add("hidden"); document.getElementById("buildScreen").classList.add("hidden"); document.getElementById("arenaScreen").classList.remove("hidden");
                UI.updateHUD(); UI.updateXP(); this.lastTime = now(); this.loop();
            },
            endArenaToBuild(playerDied = false) {
                this.justDied = playerDied;
                this.player.frenzyStacks = 0; this.player.frenzyTimer = 0; this.player.guardianShieldActive = false; this.player.guardianShieldTimer = 0; this.player.guardianShieldCooldown = 0;
                this.player.juggernautStacks = 0; this.player.timeStationary = 0; this.player.novaHitCounter = 0; this.player.novaHitTimer = 0;
                UI.updateBuffs();
                if (playerDied) { this.player.xp = Math.max(0, this.player.xp - Math.floor(this.player.xp * 0.33)); }
                this.state = "build";
                document.getElementById("arenaScreen").classList.add("hidden"); document.getElementById("buildScreen").classList.remove("hidden");
                UI.renderLoot(); UI.renderInventory(); UI.renderStats(); UI.syncEssence(); UI.updateXP(); UI.updateButtonStates();
            },
            bindControls() {
                const keys = {}, mouse = { x: 0, y: 0, down: false };
                window.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; });
                window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });
                this.canvas.addEventListener("mousemove", e => {
                    const r = this.canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top;
                    const worldMouseX = mouse.x + this.camX; const worldMouseY = mouse.y + this.camY;
                    const dx = worldMouseX - this.player.x, dy = worldMouseY - this.player.y;
                    const l = Math.hypot(dx, dy) || 1; this.player.dir = { x: dx / l, y: dy / l };
                });
                this.canvas.addEventListener("mousedown", () => { mouse.down = true; });
                window.addEventListener("mouseup", () => { mouse.down = false; });
                const step = dt => {
                    if (this.state !== "arena" || this.paused) return;
                    const s = this.player.derived(), sp = s.moveSpeed;
                    let vx = 0, vy = 0;
                    if (keys["w"]) vy -= 1; if (keys["s"]) vy += 1; if (keys["a"]) vx -= 1; if (keys["d"]) vx += 1;
                    if (keys[' ']) {
                        const equippedBoots = this.player.inv.Boots;
                        if (equippedBoots && equippedBoots.uniqueId === 'UNIQUE_BOOTS_BLINK' && this.player.blinkCooldown <= 0) {
                            const props = equippedBoots.uniqueProps;
                            this.silhouettes.push({ x: this.player.x, y: this.player.y, r: this.player.r, life: 0.5, maxLife: 0.5 });
                            this.player.x = clamp(this.player.x + this.player.moveDir.x * props.distance.value, 0 + this.player.r, this.worldW - this.player.r);
                            this.player.y = clamp(this.player.y + this.player.moveDir.y * props.distance.value, 0 + this.player.r, this.worldH - this.player.r);
                            this.player.blinkCooldown = props.cooldown.value; UI.updateBuffs(); keys[' '] = false;
                        }
                    }
                    if (vx !== 0 || vy !== 0) {
                        const l = Math.hypot(vx, vy) || 1; this.player.moveDir.x = vx / l; this.player.moveDir.y = vy / l;
                        this.player.x = clamp(this.player.x + this.player.moveDir.x * sp * dt, 0 + this.player.r, this.worldW - this.player.r);
                        this.player.y = clamp(this.player.y + this.player.moveDir.y * sp * dt, 0 + this.player.r, this.worldH - this.player.r);
                        this.player.stormRunnerTrailCd -= dt;
                        const equippedBoots = this.player.inv.Boots;
                        if (equippedBoots && equippedBoots.uniqueId === 'UNIQUE_BOOTS_ICETRAIL' && this.player.stormRunnerTrailCd <= 0) {
                            this.player.stormRunnerTrailCd = 0.1; const props = equippedBoots.uniqueProps;
                            this.groundEffects.push({ type: 'ice_trail', x: this.player.x + rand(-5, 5), y: this.player.y + rand(-5, 5), r: 20, age: 0, duration: props.duration.value, slow: props.slowPercentage.value });
                        }
                        if (this.player.juggernautStacks > 0) { this.player.juggernautStacks = 0; this.player.timeStationary = 0; UI.updateBuffs(); }
                    } else {
                        const equippedBelt = this.player.inv.Belt;
                        if (equippedBelt && equippedBelt.uniqueId === 'UNIQUE_BELT_JUGGERNAUT') {
                            const props = equippedBelt.uniqueProps;
                            if (this.player.juggernautStacks < props.maxStacks.value) {
                                this.player.timeStationary += dt;
                                if (this.player.timeStationary >= props.interval.value) { this.player.timeStationary -= props.interval.value; this.player.juggernautStacks++; UI.updateBuffs(); }
                            }
                        }
                    }
                    this.player.heal(s.lifeRegen * dt);
                    if (this.player.cooldown > 0) { this.player.cooldown -= dt; }
                    if (mouse.down && this.player.cooldown <= 0) {
                        const equippedWeapon = this.player.inv.Gun;
                        if (!equippedWeapon) return;
                        if (equippedWeapon.type === 'Gun') {
                            this.player.cooldown = 1 / s.attackSpeed; const off = 5;
                            const px = this.player.x + this.player.dir.x * (this.player.r + off); const py = this.player.y + this.player.dir.y * (this.player.r + off);
                            let bulletSpeed = 420, bulletLife = 1.5, bulletRadius = 4;
                            if (equippedWeapon.uniqueId === 'UNIQUE_GUN_PIERCE') { const props = equippedWeapon.uniqueProps; bulletRadius = 8; bulletSpeed *= props.bulletSpeedMultiplier.value; bulletLife *= props.bulletRangeMultiplier.value; }
                            if (equippedWeapon.uniqueId === 'UNIQUE_GUN_SHOTGUN') {
                                const props = equippedWeapon.uniqueProps; const totalAngle = props.spreadAngle.value * (Math.PI / 180);
                                const angleStep = totalAngle / (props.bulletCount.value - 1); const startAngle = -totalAngle / 2;
                                for (let i = 0; i < props.bulletCount.value; i++) {
                                    const angle = startAngle + i * angleStep;
                                    const dirX = this.player.dir.x * Math.cos(angle) - this.player.dir.y * Math.sin(angle);
                                    const dirY = this.player.dir.x * Math.sin(angle) + this.player.dir.y * Math.cos(angle);
                                    this.bullets.push({ x: px, y: py, r: bulletRadius, vx: dirX * bulletSpeed, vy: dirY * bulletSpeed, life: bulletLife, hitEnemies: new Set(), isNova: false });
                                }
                            } else { this.bullets.push({ x: px, y: py, r: bulletRadius, vx: this.player.dir.x * bulletSpeed, vy: this.player.dir.y * bulletSpeed, life: bulletLife, hitEnemies: new Set(), isNova: false }); }
                        } else if (equippedWeapon.type === 'Sword') {
                            if (this.player.canCombo) { this.player.cooldown = 0; this.player.canCombo = false; } else { this.player.cooldown = 1 / s.attackSpeed; }
                            const totalSwingArc = Math.PI * 0.8; this.player.swordAttackDirection *= -1; this.swordStartAngleOffset = this.player.swordAttackDirection * (totalSwingArc / 2); this.swingAngle = 0;
                            this.swingEffect = { life: 0.15, totalAngle: totalSwingArc, startOffset: this.swordStartAngleOffset, direction: this.player.swordAttackDirection, comboWindow: 0.15 };
                            const attackRange = 75; const playerAngle = Math.atan2(this.player.dir.y, this.player.dir.x);
                            const effectDistance = attackRange * 0.6; const effectX = this.player.x + Math.cos(playerAngle) * effectDistance; const effectY = this.player.y + Math.sin(playerAngle) * effectDistance;
                            this.slashEffects.push({ x: effectX, y: effectY, angle: playerAngle, life: 0.25, maxLife: 0.25, radius: attackRange * 0.7, arc: totalSwingArc * 0.9, direction: this.player.swordAttackDirection });
                        }
                    }
                };
                this.updateControls = step;
            },
            pause(v) { this.paused = v !== undefined ? v : !this.paused; this.frame.classList.toggle("paused", this.paused); document.getElementById("pauseBtn").textContent = this.paused ? "Devam" : "Duraklat"; },
            spawnEnemy() {
                const rareChance = RARE_CHANCE_BASE + (this.player.wave * RARE_CHANCE_WAVE_SCALE); const magicChance = MAGIC_CHANCE_BASE + (this.player.wave * MAGIC_CHANCE_WAVE_SCALE);
                const roll = Math.random(); let rarity = 'Normal';
                if (roll < rareChance) { rarity = 'Rare'; } else if (roll < rareChance + magicChance) { rarity = 'Magic'; }
                const packOptions = PACK_STRUCTURES[rarity]; const packSize = weightedChoice(packOptions.map(p => ({ value: p.size, weight: p.weight })));
                const r = Math.random(); let type = 'grunt';
                if (r < 0.028) { type = 'bomber'; } else if (r < 0.056) { type = 'shaman'; } else if (r < 0.096) { type = 'slime'; } else if (r < 0.136) { type = 'brute'; } else if (r < 0.236) { type = 'rusher'; } else if (r < 0.436) { type = 'watcher'; }
                const minRadius = (this.w + this.h) / 4; const maxRadius = Math.hypot(this.worldW / 2, this.worldH / 2);
                const spawnRadius = rand(minRadius, maxRadius); const centralAngle = rand(0, Math.PI * 2);
                for (let i = 0; i < packSize; i++) {
                    const angleOffset = (packSize > 1) ? (i - (packSize - 1) / 2) * 0.2 : 0; const finalAngle = centralAngle + angleOffset;
                    let finalX = this.player.x + Math.cos(finalAngle) * spawnRadius; let finalY = this.player.y + Math.sin(finalAngle) * spawnRadius;
                    finalX = clamp(finalX, 0, this.worldW); finalY = clamp(finalY, 0, this.worldH);
                    this.enemies.push(new Enemy(finalX, finalY, this.player.wave, type, rarity));
                }
            },
            triggerChainLightning(initialTarget, damage) {
                const chainedEnemies = new Set([initialTarget.id]); let lastTarget = initialTarget; const maxChains = 8; const chainRange = 150;
                for (let i = 0; i < maxChains - 1; i++) {
                    let closestEnemy = null; let minDistance = Infinity;
                    for (const enemy of this.enemies) {
                        if (!chainedEnemies.has(enemy.id) && enemy.life > 0) {
                            const distance = Math.hypot(lastTarget.x - enemy.x, lastTarget.y - enemy.y);
                            if (distance < chainRange && distance < minDistance) { minDistance = distance; closestEnemy = enemy; }
                        }
                    }
                    if (closestEnemy) {
                        this.visualEffects.push({ type: 'lightning', from: {x: lastTarget.x, y: lastTarget.y}, to: {x: closestEnemy.x, y: closestEnemy.y}, life: 0.2 });
                        this.applyDamageToEnemy(closestEnemy, damage, false, "#818cf8");
                        chainedEnemies.add(closestEnemy.id); lastTarget = closestEnemy;
                    } else { break; }
                }
            },
            update(dt) {
                this.time += dt;
                for(let i = this.visualEffects.length - 1; i >= 0; i--) { const effect = this.visualEffects[i]; effect.life -= dt; if(effect.life <= 0) { this.visualEffects.splice(i, 1); } }
                if (this.swingEffect) {
                    this.swingEffect.life -= dt;
                    if (this.swingEffect.life <= 0) {
                        const comboWindow = this.swingEffect.comboWindow; this.swingEffect = null; this.swingAngle = 0; this.player.canCombo = true;
                        setTimeout(() => { if (this.player.canCombo) { this.player.canCombo = false; this.player.cooldown = 1 / this.player.derived().attackSpeed; } }, comboWindow * 1000);
                    } else {
                        const progress = 1 - (this.swingEffect.life / 0.15); const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
                        this.swingAngle = this.swingEffect.startOffset - (this.swingEffect.direction * this.swingEffect.totalAngle * easeProgress);
                        const p = this.player; const s = p.derived(); const swordLengthForHitbox = 75; const swordMinDistance = p.r + 5;
                        const playerAngle = Math.atan2(p.dir.y, p.dir.x); const currentSwingAngle = playerAngle + this.swingAngle;
                        for (const e of this.enemies) {
                            if (this.swingEffect.hitEnemies && this.swingEffect.hitEnemies.has(e.id)) continue;
                            const distToEnemy = Math.hypot(e.x - p.x, e.y - p.y);
                            if (distToEnemy < swordMinDistance + swordLengthForHitbox + e.r && distToEnemy > swordMinDistance - e.r) {
                                const angleToEnemy = Math.atan2(e.y - p.y, e.x - p.x); let angleDiff = Math.abs(currentSwingAngle - angleToEnemy);
                                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; const swordAngularThickness = 0.30;
                                if (angleDiff < swordAngularThickness / 2) {
                                    if (!this.swingEffect.hitEnemies) this.swingEffect.hitEnemies = new Set();
                                    this.swingEffect.hitEnemies.add(e.id);
                                    this.applyHitEffects(e, s);
                                }
                            }
                        }
                    }
                }
                for (let i = this.slashEffects.length - 1; i >= 0; i--) { const slash = this.slashEffects[i]; slash.life -= dt; if (slash.life <= 0) { this.slashEffects.splice(i, 1); } }
                this.updateControls(dt);
                let targetCamX = this.player.x - this.w / 2; let targetCamY = this.player.y - this.h / 2;
                this.camX = clamp(targetCamX, 0, this.worldW - this.w); this.camY = clamp(targetCamY, 0, this.worldH - this.h);
                if (this.player.frenzyTimer > 0) { this.player.frenzyTimer -= dt; if (this.player.frenzyTimer <= 0) { this.player.frenzyStacks--; if (this.player.frenzyStacks > 0) { const helmet = this.player.inv.Helmet; if (helmet && helmet.uniqueId === 'UNIQUE_HELMET_FRENZY') { this.player.frenzyTimer = helmet.uniqueProps.duration.value; } } } }
                if (this.player.guardianShieldTimer > 0) { this.player.guardianShieldTimer -= dt; if (this.player.guardianShieldTimer <= 0) { this.player.guardianShieldActive = false; const equippedChest = this.player.inv.Chest; if (equippedChest && equippedChest.uniqueId === 'UNIQUE_CHEST_GUARDIAN') { this.player.guardianShieldCooldown = equippedChest.uniqueProps.cooldown.value; } } } else if (this.player.guardianShieldCooldown > 0) { this.player.guardianShieldCooldown -= dt; if (this.player.guardianShieldCooldown < 0) { this.player.guardianShieldCooldown = 0; } }
                if (this.player.blinkCooldown > 0) { this.player.blinkCooldown -= dt; }
                if (this.player.novaHitTimer > 0) { this.player.novaHitTimer -= dt; if (this.player.novaHitTimer <= 0) { this.player.novaHitCounter = 0; } }
                if (this.player.greedBuffTimer > 0) { this.player.greedBuffTimer -= dt; }
                UI.updateBuffs();
                this.timer -= dt;
                if (this.timer <= 0) { this.endArenaToBuild(); return; }
                UI.updateTimer(this.timer);
                const sc = WAVE_SCALE(this.player.wave), baseSpawn = 4.0;
                this.spawnClock -= dt;
                if (this.spawnClock <= 0) { this.spawnEnemy(); this.spawnClock = baseSpawn / sc.spawnMul; }
                for (let i = this.bullets.length - 1; i >= 0; i--) { const b = this.bullets[i]; b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt; if (b.life <= 0 || b.x < -30 || b.x > this.worldW + 30 || b.y < -30 || b.y > this.worldH + 30) { this.bullets.splice(i, 1); } }
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) { const b = this.enemyBullets[i]; b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt; if (b.life <= 0) { this.enemyBullets.splice(i, 1); continue; } if (Math.hypot(this.player.x - b.x, this.player.y - b.y) < this.player.r + b.r) { this.player.takeDamage(b.dmg); this.enemyBullets.splice(i, 1); continue; } }
                for (let i = this.groundEffects.length - 1; i >= 0; i--) { const effect = this.groundEffects[i]; effect.age += dt; if (effect.age >= effect.duration) { this.groundEffects.splice(i, 1); continue; } if (effect.type !== 'ice_trail') { if (effect.age < effect.growTime) { effect.r = (effect.age / effect.growTime) * effect.maxR; } else { effect.r = effect.maxR; } if (effect.age >= effect.duration) { effect.alpha = 1 - (effect.age - effect.duration) / effect.fadeTime; } if (effect.alpha <= 0) { this.groundEffects.splice(i, 1); continue; } if (Math.hypot(this.player.x - effect.x, this.player.y - effect.y) < this.player.r + effect.r) { this.player.takeDamage(effect.dps * dt); } } }
                for (const e of this.enemies) { 
                    if (e.spawnStunTimer > 0) { e.spawnStunTimer -= dt; continue; } 
                    if (e.stunCD > 0) { e.stunCD -= dt; continue; }
                    if (e.debuffs.frozen.isActive) { e.debuffs.frozen.duration -= dt; if (e.debuffs.frozen.duration <= 0) { e.debuffs.frozen.isActive = false; } else { continue; } }
                    if (e.debuffs.burning.isActive) {
                        e.debuffs.burning.duration -= dt; e.debuffs.burning.nextTick -= dt;
                        if (e.debuffs.burning.duration <= 0) { e.debuffs.burning.isActive = false; } 
                        else if (e.debuffs.burning.nextTick <= 0) { this.applyDamageToEnemy(e, e.debuffs.burning.damagePerSecond, false, "#f97316"); e.debuffs.burning.nextTick += 1.0; }
                    }
                    let slowMultiplier = 1.0;
                    if (e.debuffs.chill.stacks > 0) { if (this.time - e.debuffs.chill.lastHitTime > 2.0) { e.debuffs.chill.stacks = 0; } else { slowMultiplier = 1.0 - (e.debuffs.chill.stacks * 0.08); } }
                    e.actionCD -= dt; let finalSpeed = e.speed * slowMultiplier;
                    for (const trail of this.groundEffects) { if (trail.type === 'ice_trail' && Math.hypot(e.x - trail.x, e.y - trail.y) < e.r + trail.r) { finalSpeed *= (1 - trail.slow); break; } }
                    const distToPlayer = Math.hypot(this.player.x - e.x, this.player.y - e.y);
                    switch (e.type) { case 'watcher': if (distToPlayer > e.attackRange) { const d = distToPlayer || 1; e.x += ((this.player.x - e.x) / d) * finalSpeed * dt; e.y += ((this.player.y - e.y) / d) * finalSpeed * dt; } else if (e.actionCD <= 0) { const d = distToPlayer || 1; this.enemyBullets.push({ x: e.x, y: e.y, r: 4, vx: ((this.player.x - e.x) / d) * 220, vy: ((this.player.y - e.y) / d) * 220, life: 3.0, dmg: e.damage }); e.actionCD = 1 / sc.spawnMul; } break; case 'shaman': if (distToPlayer > e.attackRange) { const d = distToPlayer || 1; e.x += ((this.player.x - e.x) / d) * finalSpeed * dt; e.y += ((this.player.y - e.y) / d) * finalSpeed * dt; } else if (e.actionCD <= 0 && !e.isCasting) { let bestTarget = null, minDist = Infinity; for (const other of this.enemies) { if (other.id === e.id || other.type === 'shaman' || other.blessedBy) continue; if (Math.hypot(e.x - other.x, e.y - other.y) < minDist) { minDist = Math.hypot(e.x - other.x, e.y - other.y); bestTarget = other; } } if (bestTarget) { e.isCasting = true; e.castTime = 1.0; e.actionCD = 4.0; setTimeout(() => { if (e.life > 0 && bestTarget.life > 0) { bestTarget.blessedBy = e.id; } e.isCasting = false; }, 1000); } else { e.actionCD = 1.0; } } if (e.isCasting) e.castTime -= dt; break; default: const d = distToPlayer || 1; e.x += ((this.player.x - e.x) / d) * finalSpeed * dt; e.y += ((this.player.y - e.y) / d) * finalSpeed * dt; if (e.type === 'bomber' && distToPlayer < this.player.r + e.r) { e.life = 0; } break; }
                    if (distToPlayer < e.r + this.player.r) { const nx = (e.x - this.player.x) / distToPlayer, ny = (e.y - this.player.y) / distToPlayer, push = (e.r + this.player.r) - distToPlayer; e.x += nx * push; e.y += ny * push; e.hitCD -= dt; if (e.hitCD <= 0) { const equippedChest = this.player.inv.Chest; if (equippedChest && equippedChest.uniqueId === 'UNIQUE_CHEST_THORNS') { this.applyDamageToEnemy(e, e.damage * equippedChest.uniqueProps.reflectPercentage.value, false, "#f59e0b"); } this.player.takeDamage(e.damage); e.stunCD = 1 / 3; e.hitCD = 0.6; } } else { e.hitCD -= dt; } 
                }
                const s = this.player.derived();
                const equippedGun = this.player.inv.Gun;
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const b = this.bullets[i]; let bulletRemoved = false;
                    for (const e of this.enemies) {
                        if (Math.hypot(e.x - b.x, e.y - b.y) < (e.r + b.r)) {
                            if (!b.hitEnemies.has(e.id)) {
                                b.hitEnemies.add(e.id); this.applyHitEffects(e, s, b);
                                if (!equippedGun || equippedGun.uniqueId !== 'UNIQUE_GUN_PIERCE') { this.bullets.splice(i, 1); bulletRemoved = true; break; }
                            }
                        }
                    }
                    if (bulletRemoved) continue;
                }
                const killed = this.enemies.filter(e => e.life <= 0);
                if (killed.length) { for (const e of killed) { this.player.kill++; this.player.totalKills++; this.player.gainXP(e.xp); if (e.rarity === 'Rare') { const equippedRing = this.player.inv.Ring; if (equippedRing && equippedRing.uniqueId === 'UNIQUE_RING_GREED') { this.player.greedBuffTimer = equippedRing.uniqueProps.duration.value; } } const equippedHelmet = this.player.inv.Helmet; if (equippedHelmet && equippedHelmet.uniqueId === 'UNIQUE_HELMET_FRENZY') { const props = equippedHelmet.uniqueProps; this.player.frenzyStacks = Math.min(props.maxStacks.value, this.player.frenzyStacks + 1); this.player.frenzyTimer = props.duration.value; UI.updateBuffs(); } if (e.type === 'slime') { for (let i = 0; i < 4; i++) { this.enemies.push(new Enemy(e.x + rand(-15, 15), e.y + rand(-15, 15), this.player.wave, 'rusher', 'Normal', 0.20)); } } if (e.type === 'bomber') { this.floaters.push({ x: e.x, y: e.y, text: "BOOM!", color: "#f97316", size: 22, vy: -15, life: 1.2 }); const explosionR = e.r * 1.5; if (Math.hypot(this.player.x - e.x, this.player.y - e.y) < this.player.r + explosionR) { this.player.takeDamage(e.damage); } this.groundEffects.push({ type: 'explosion', x: e.x, y: e.y, r: 0, maxR: e.r * 3, age: 0, duration: 5.0, growTime: 0.5, fadeTime: 2.0, alpha: 1.0, dps: 6 * 0.5 * sc.dmgMul }); } if (e.type === 'shaman') { for (const other of this.enemies) { if (other.blessedBy === e.id) { other.blessedBy = null; } } } let dropMultiplier = 1, qualityMultiplier = 1, maxDrops = 1; if (e.rarity === 'Magic') { dropMultiplier = 2; qualityMultiplier = 2; maxDrops = 2; } else if (e.rarity === 'Rare') { dropMultiplier = 4; qualityMultiplier = 4; maxDrops = 4; } const mf = this.player.derived().magicFind; const baseDropChance = BASE_DROP + (1 - BASE_DROP) * (1 - 1 / (1 + mf / 75)); for (let i = 0; i < maxDrops; i++) { if (Math.random() < baseDropChance * dropMultiplier) { const item_ilvl = Math.max(1, this.player.wave + randi(-1, 1)); const rollModifier = (1 + Math.log10(1 + mf / 25)) * qualityMultiplier; const r = Math.random() / rollModifier; const rar = (r < 0.7) ? "N" : (r < 0.95) ? "M" : (r < 0.998) ? "R" : "U"; const type = choice(TYPE_KEYS); const item = new Item({ type, rarity: rar, ilvl: item_ilvl }); this.player.loot.unshift(item); const color = rar === "N" ? "#9ca3af" : rar === "M" ? "#60a5fa" : rar === "R" ? "#fbbf24" : "#ef4444"; this.floaters.push({ x: e.x, y: e.y - (i * 18), text: "+1 item", color, size: 14, vy: -18, life: 1.2 }); } } } this.enemies = this.enemies.filter(e => e.life > 0); UI.updateHUD(); }
                for (let i = this.floaters.length - 1; i >= 0; i--) { const f = this.floaters[i]; f.y += f.vy * dt; f.life -= dt; if (f.life <= 0) this.floaters.splice(i, 1); }
                for (let i = this.silhouettes.length - 1; i >= 0; i--) { const s = this.silhouettes[i]; s.life -= dt; if (s.life <= 0) { this.silhouettes.splice(i, 1); } }
                if (this.player.life <= 0) { this.player.life = this.player.derived().maxLife; this.endArenaToBuild(true); return; }
            },
            applyDamageToEnemy(enemy, damage, isCrit = false, floaterColor = null) {
                let finalDamage = damage;
                if (enemy.blessedBy) { finalDamage *= 0.25; }
                if (enemy.debuffs.frozen.isActive) { finalDamage *= (1 + enemy.debuffs.frozen.armorReduction); }
                enemy.life -= finalDamage; enemy.showHP = true;
                const color = floaterColor ? floaterColor : (isCrit ? "#ef4444" : "#9ca3af");
                const size = isCrit ? 14 : 12;
                this.floaters.push({ x: enemy.x, y: enemy.y - enemy.r - 18, text: Math.round(finalDamage), color: color, size: size, vy: -20, life: 1.0 });
            },
            applyHitEffects(e, s, b = null) {
                let totalHitDamage = s.physicalDamage + s.fireDamage + s.lightningDamage + s.coldDamage;
                let crit = false;
                if (Math.random() < s.critChance / 100) { totalHitDamage *= (s.critDamage / 100); crit = true; }
                const equippedGun = this.player.inv.Gun;
                if (b && b.isNova) { totalHitDamage *= b.novaDmgMult; }
                else if (equippedGun && equippedGun.uniqueId === 'UNIQUE_GUN_SHOTGUN') { totalHitDamage *= equippedGun.uniqueProps.damageModifier.value; }
                this.applyDamageToEnemy(e, totalHitDamage, crit);
                if (b) {
                    const equippedBelt = this.player.inv.Belt;
                    if (!b.isNova && equippedBelt && equippedBelt.uniqueId === 'UNIQUE_BELT_NOVABLAST') {
                        const props = equippedBelt.uniqueProps; this.player.novaHitCounter++; this.player.novaHitTimer = props.resetTime.value; UI.updateBuffs();
                        if (this.player.novaHitCounter >= props.hitsRequired.value) {
                            this.player.novaHitCounter = 0; this.player.novaHitTimer = 0;
                            const projectileCount = props.projectileCount.value; const novaDmgMult = props.damageMultiplier.value; const bulletSpeed = 350;
                            for (let j = 0; j < projectileCount; j++) { const angle = (j / projectileCount) * Math.PI * 2; const dirX = Math.cos(angle); const dirY = Math.sin(angle); this.bullets.push({ x: this.player.x, y: this.player.y, r: 6, vx: dirX * bulletSpeed, vy: dirY * bulletSpeed, life: 1.0, hitEnemies: new Set(), isNova: true, novaDmgMult: novaDmgMult }); }
                        }
                    }
                }
                const hasFire = s.fireDamage > 0; const hasCold = s.coldDamage > 0; const hasLightning = s.lightningDamage > 0;
                if (hasFire && hasCold) { /* Efekt yok */ } 
                else {
                    if (hasFire) { e.debuffs.burning.isActive = true; e.debuffs.burning.damagePerSecond = s.fireDamage; e.debuffs.burning.duration = 3.0; e.debuffs.burning.nextTick = 1.0; }
                    if (hasCold && !e.debuffs.frozen.isActive) {
                        e.debuffs.chill.stacks = Math.min(10, e.debuffs.chill.stacks + 1);
                        e.debuffs.chill.lastHitTime = this.time;
                        if (e.debuffs.chill.stacks >= 10) { e.debuffs.frozen.isActive = true; e.debuffs.frozen.duration = 2.5; e.debuffs.chill.stacks = 0; }
                    }
                }
                if (hasLightning) { this.triggerChainLightning(e, s.lightningDamage); }
            },
            render() {
                const ctx = this.ctx; ctx.clearRect(0, 0, this.w, this.h); ctx.save(); ctx.translate(-this.camX, -this.camY);
                if (this.backgroundPattern) { ctx.fillStyle = this.backgroundPattern; ctx.fillRect(0, 0, this.worldW, this.worldH); } else { ctx.fillStyle = "#111"; ctx.fillRect(0, 0, this.worldW, this.worldH); }
                for (const effect of this.groundEffects) { if (effect.type === 'ice_trail') { ctx.globalAlpha = 0.5 * (1 - (effect.age / effect.duration)); ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.r, 0, Math.PI * 2); ctx.fill(); } else { ctx.globalAlpha = effect.alpha * 0.5; ctx.fillStyle = '#4d7c0f'; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.r, 0, Math.PI * 2); ctx.fill(); } }
                ctx.globalAlpha = 1.0;
                for (const s of this.silhouettes) { const alpha = Math.max(0, s.life / s.maxLife); ctx.globalAlpha = alpha * 0.6; ctx.fillStyle = "#3b82f6"; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill(); }
                ctx.globalAlpha = 1.0;
                const p = this.player; const equippedWeapon = p.inv.Gun;
                ctx.fillStyle = "rgba(0,0,0,.25)"; ctx.beginPath(); ctx.arc(p.x + 2, p.y + 2, p.r, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath();
                if (!equippedWeapon || equippedWeapon.type !== 'Sword') { ctx.fillStyle = "#60a5fa"; ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); } else { ctx.fillStyle = "#60a5fa"; ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); }
                ctx.fill();
                if (equippedWeapon && equippedWeapon.type === 'Sword') { const swordLength = 60; const bladeBodyLength = 45; const hiltLength = 10; const guardWidth = 22; const bladeWidth = 10; const hiltWidth = 6; const swordOffset = p.r + 5; ctx.save(); ctx.translate(p.x, p.y); const playerAngle = Math.atan2(p.dir.y, p.dir.x); ctx.rotate(playerAngle + this.swingAngle); ctx.fillStyle = "#7a5230"; ctx.fillRect(swordOffset - hiltLength, -hiltWidth / 2, hiltLength, hiltWidth); ctx.fillStyle = "#a0a0a0"; ctx.fillRect(swordOffset - 5, -guardWidth / 2, 5, guardWidth); ctx.fillStyle = "#d0d0d0"; ctx.fillRect(swordOffset, -bladeWidth / 2, bladeBodyLength, bladeWidth); ctx.beginPath(); ctx.moveTo(swordOffset + bladeBodyLength, -bladeWidth / 2); ctx.lineTo(swordOffset + swordLength, 0); ctx.lineTo(swordOffset + bladeBodyLength, bladeWidth / 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
                for (const slash of this.slashEffects) { ctx.globalAlpha = slash.life / slash.maxLife * 0.7; ctx.strokeStyle = "rgba(255, 255, 255, 1)"; ctx.lineWidth = 4; ctx.lineCap = "round"; ctx.save(); ctx.translate(slash.x, slash.y); const startAngle = slash.angle - (slash.arc / 2) * slash.direction; const endAngle = slash.angle + (slash.arc / 2) * slash.direction; ctx.beginPath(); if (slash.direction === 1) { ctx.arc(0, 0, slash.radius, startAngle, endAngle, false); } else { ctx.arc(0, 0, slash.radius, endAngle, startAngle, false); } ctx.stroke(); ctx.restore(); }
                ctx.globalAlpha = 1.0;
                if (p.guardianShieldActive) { ctx.globalAlpha = 0.4 + Math.sin(this.time * 8) * 0.2; ctx.beginPath(); ctx.arc(p.x + 2, p.y + 2, p.r * 1.3, 0, Math.PI * 2); ctx.fillStyle = p.guardianShieldColor; ctx.fill(); ctx.globalAlpha = 1.0; }
                if (!equippedWeapon || equippedWeapon.type !== 'Sword') { ctx.fillStyle = "#374151"; ctx.beginPath(); ctx.arc(p.x + p.dir.x * (p.r + 8), p.y + p.dir.y * (p.r + 8), 6, 0, Math.PI * 2); ctx.fill(); }
                ctx.fillStyle = "#ef4444"; for (const b of this.bullets) { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill(); }
                ctx.fillStyle = "#a855f7"; for (const b of this.enemyBullets) { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill(); }
                for (const e of this.enemies) { 
                    if (e.showHP) { const w = 24, h = 5; ctx.fillStyle = "#6b7280"; ctx.fillRect(e.x - w / 2, e.y - e.r - 16, w, h); ctx.fillStyle = "#ef4444"; ctx.fillRect(e.x - w / 2, e.y - e.r - 16, w * (e.life / e.maxLife), h); } 
                    if (e.rarity === 'Magic' || e.rarity === 'Rare') { ctx.font = "bold 13px Inter, system-ui"; ctx.textAlign = "center"; ctx.fillStyle = e.rarity === 'Magic' ? '#60a5fa' : '#fbbf24'; ctx.fillText(e.type.toUpperCase(), e.x, e.y - e.r - 22); } 
                    ctx.fillStyle = e.color; 
                    const drawShape = (sides, radius, color, rotation = 0) => { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(e.x + radius * Math.cos(rotation), e.y + radius * Math.sin(rotation)); for (let i = 1; i <= sides; i++) { const angle = (i / sides) * 2 * Math.PI + rotation; ctx.lineTo(e.x + radius * Math.cos(angle), e.y + radius * Math.sin(angle)); } ctx.closePath(); ctx.fill(); }; 
                    if (e.blessedBy) { ctx.strokeStyle = "#a855f7"; ctx.lineWidth = 6; ctx.globalAlpha = 0.8; ctx.beginPath(); if (e.shape === 'hexagon') { const sides = 6; const radius = e.r + 5; ctx.moveTo(e.x + radius * Math.cos(Math.PI / 6), e.y + radius * Math.sin(Math.PI / 6)); for (let i = 1; i <= sides; i++) { const angle = (i / sides) * 2 * Math.PI + Math.PI / 6; ctx.lineTo(e.x + radius * Math.cos(angle), e.y + radius * Math.sin(angle)); } } else if (e.shape === 'pentagon') { const sides = 5; const radius = e.r + 5; ctx.moveTo(e.x + radius * Math.cos(Math.PI / 10), e.y + radius * Math.sin(Math.PI / 10)); for (let i = 1; i <= sides; i++) { const angle = (i / sides) * 2 * Math.PI + Math.PI / 10; ctx.lineTo(e.x + radius * Math.cos(angle), e.y + radius * Math.sin(angle)); } } else { ctx.arc(e.x, e.y, e.r + 5, 0, Math.PI * 2); } ctx.closePath(); ctx.stroke(); ctx.globalAlpha = 1.0; } 
                    ctx.save();
                    if (e.debuffs.burning.isActive) { const pulse = Math.sin(this.time * 15) * 2; ctx.fillStyle = "rgba(255, 100, 0, 0.4)"; ctx.beginPath(); ctx.arc(e.x, e.y, e.r + 4 + pulse, 0, Math.PI * 2); ctx.fill(); }
                    if (e.debuffs.frozen.isActive) { ctx.fillStyle = "rgba(173, 216, 230, 0.7)"; ctx.beginPath(); ctx.arc(e.x, e.y, e.r * 1.1, 0, Math.PI * 2); ctx.fill(); }
                    if (e.type === 'bomber') { ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#a1a1aa'; for (let i = 0; i < 8; i++) { const angle = (i / 8) * 2 * Math.PI; ctx.beginPath(); ctx.arc(e.x + e.r * Math.cos(angle), e.y + e.r * Math.sin(angle), e.r * 0.16, 0, Math.PI * 2); ctx.fill(); } } else if (e.type === 'watcher') { ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#d4d4d8'; ctx.beginPath(); ctx.arc(e.x, e.y, e.r * 0.7, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#18181b'; ctx.beginPath(); ctx.arc(e.x, e.y, e.r * 0.4, 0, Math.PI * 2); ctx.fill(); } else if (e.type === 'shaman') { drawShape(5, e.r, e.color, Math.PI / 10); ctx.fillStyle = "#fff"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = `${e.r * 1.4}px sans-serif`; ctx.fillText('♰', e.x, e.y + 2); if (e.isCasting) { for (let i = 0; i < 5; i++) { const angle = now() / 100 + i * (Math.PI * 2 / 5); const dist = e.r + 10 + Math.sin(now() / 100) * 5; ctx.fillStyle = `rgba(168, 85, 247, ${1 - e.castTime})`; ctx.font = `bold ${16}px sans-serif`; ctx.fillText('*', e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist); } } } else if (e.shape === 'hexagon') { drawShape(6, e.r, e.color, Math.PI / 6); } else if (e.shape === 'pentagon') { drawShape(5, e.r, e.color, Math.PI / 10); } else { ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill(); }
                    if (e.debuffs.chill.stacks > 0 && !e.debuffs.frozen.isActive) { const chillOpacity = 0.1 + e.debuffs.chill.stacks * 0.04; ctx.fillStyle = `rgba(0, 150, 255, ${chillOpacity})`; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill(); }
                    if (e.debuffs.burning.isActive) { ctx.fillStyle = `rgba(251, 146, 60, ${rand(0.5, 1.0)})`; ctx.beginPath(); ctx.arc(e.x + rand(-e.r/2, e.r/2), e.y + rand(-e.r/2, e.r/2), rand(2, 4), 0, Math.PI * 2); ctx.fill(); }
                    ctx.restore();
                }
                for (const f of this.floaters) { ctx.globalAlpha = Math.max(0, Math.min(1, f.life)); ctx.fillStyle = f.color; ctx.font = `bold ${f.size}px Inter, system-ui`; ctx.textAlign = "center"; ctx.fillText(f.text, f.x, f.y); ctx.globalAlpha = 1; }
                for(const effect of this.visualEffects) { if (effect.type === 'lightning') { ctx.strokeStyle = `rgba(139, 139, 247, ${effect.life / 0.2 * 0.8})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(effect.from.x, effect.from.y); ctx.lineTo(effect.to.x, effect.to.y); ctx.stroke(); } }
                ctx.restore();
                document.getElementById("xpLabel").textContent = `Xp ${fmt(this.player.xp, 0)}/${fmt(this.player.xpNext, 0)}`;
                const life_s = this.player.derived(); const orbR = 69; const orbPadding = 14; const cx = orbPadding + orbR; const cy = this.h - orbPadding - orbR;
                ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, orbR, 0, Math.PI * 2); ctx.shadowColor = "rgba(0,0,0,.35)"; ctx.shadowBlur = 8; ctx.fillStyle = "#991b1b"; ctx.fill();
                ctx.beginPath(); ctx.arc(cx, cy, orbR - 4, 0, Math.PI * 2); ctx.fillStyle = "#ef4444"; ctx.fill();
                const lifePct = Math.max(0, Math.min(1, p.life / life_s.maxLife));
                if (lifePct < 1) { const missing = 1 - lifePct; const angle = missing * Math.PI * 2; const start = -Math.PI / 2 - angle / 2; const end = start + angle; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, orbR - 4, start, end); ctx.closePath(); ctx.fillStyle = "#9ca3af"; ctx.fill(); }
                ctx.globalAlpha = .15; ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(cx - 12, cy - 16, orbR * .6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1; ctx.fillStyle = "#fff"; ctx.font = "bold 12px Inter"; ctx.textAlign = "center"; ctx.fillText(`Life ${fmt(p.life, 0)}/${fmt(life_s.maxLife, 0)}`, cx, cy + 4);
                ctx.restore();
            },
            renderMinimap() {
                const mCtx = this.minimapCtx; const mW = this.minimap.width; const mH = this.minimap.height; const scaleX = mW / this.worldW; const scaleY = mH / this.worldH;
                mCtx.clearRect(0, 0, mW, mH);
                mCtx.strokeStyle = "rgba(255, 255, 255, 0.4)"; mCtx.lineWidth = 2; mCtx.strokeRect(this.camX * scaleX, this.camY * scaleY, this.w * scaleX, this.h * scaleY);
                mCtx.fillStyle = "#22c55e"; const playerSize = 6; mCtx.fillRect(this.player.x * scaleX - playerSize / 2, this.player.y * scaleY - playerSize / 2, playerSize, playerSize);
                const enemySize = 5;
                for (const e of this.enemies) { if (e.rarity === 'Rare') { mCtx.fillStyle = '#eab308'; } else if (e.rarity === 'Magic') { mCtx.fillStyle = '#60a5fa'; } else { mCtx.fillStyle = '#ef4444'; } mCtx.fillRect(e.x * scaleX - enemySize / 2, e.y * scaleY - enemySize / 2, enemySize, enemySize); }
            },
            loop() {
                if (this.state !== "arena") return;
                const t = now(); const dt = Math.min(0.05, (t - this.lastTime) / 1000); this.lastTime = t;
                if (!this.paused) { this.update(dt); this.render(); this.renderMinimap(); }
                requestAnimationFrame(() => this.loop());
            }
        };

        const UI = {
            hoverStat: "",
            elements: {
                startBtn: document.getElementById("startBtn"), pauseBtn: document.getElementById("pauseBtn"),
                nextWave: document.getElementById("nextWave"), sameWave: document.getElementById("sameWave"),
                hudWave: document.getElementById("hudWave"), hudKill: document.getElementById("hudKill"),
                hudTotalKill: document.getElementById("hudTotalKill"), hudLevel: document.getElementById("hudLevel"),
                buildPlayerLevel: document.getElementById("buildPlayerLevel"), xpFill: document.getElementById("xpFill"),
                timerLabel: document.getElementById("timerLabel"), timerBox: document.getElementById("timerBox"),
                essA: document.getElementById("essCount"), essB: document.getElementById("essCountBuild"),
                lootGrid: document.getElementById("lootGrid"), invGrid: document.getElementById("invGrid"),
                statPanel: document.getElementById("statPanel"), levelModal: document.getElementById("levelModal"),
                levelOptions: document.getElementById("levelOptions"), sortStat: document.getElementById("sortStat"),
                sortTypeSel: document.getElementById("sortTypeSel"), dismSel: document.getElementById("dismSel"),
                dismAll: document.getElementById("dismAll"), clearSel: document.getElementById("clearSel"),
                upgradeBtn: document.getElementById("upgradeBtn"), confirmModal: document.getElementById("confirmModal"),
                confirmYes: document.getElementById("confirmYes"), confirmNo: document.getElementById("confirmNo"),
                sortLevel: document.getElementById("sortLevel")
            },
            // DÜZELTME: Kılıç ve Eldiven emojileri eklendi
            populateSortOptions() {
                for (const k of STAT_KEYS) { const o = document.createElement("option"); o.value = k; o.textContent = k; this.elements.sortStat.appendChild(o); }
                for (const t of TYPE_KEYS) { const o = document.createElement("option"); o.value = t; o.textContent = `${({Gun:"🔫", Sword: "⚔️", Helmet:"👑",Chest:"🥻",Boots:"👞",Belt:"🩹",Ring:"💍", Gloves: "🧤"})[t]} ${t}`; this.elements.sortTypeSel.appendChild(o); }
            },
            setHoverStat(stat) { this.hoverStat = stat || ""; this.refreshHighlights(); },
            refreshHighlights() { document.querySelectorAll(".ic-aff").forEach(el => { el.classList.toggle("hl", el.dataset.stat === this.hoverStat && this.hoverStat !== ""); }); },
            updateHUD() {
                this.elements.hudWave.textContent = Game.player.wave; this.elements.hudKill.textContent = Game.player.kill;
                this.elements.hudTotalKill.textContent = Game.player.totalKills; this.elements.hudLevel.textContent = Game.player.level;
                this.elements.buildPlayerLevel.textContent = Game.player.level; this.syncEssence();
            },
            updateXP() { const cur = Game.player.xp, need = Game.player.xpNext, pct = Math.max(0, Math.min(100, 100 * cur / need)); this.elements.xpFill.style.width = pct + "%"; },
            updateTimer(t) { this.elements.timerLabel.textContent = `${fmt(t,2)}s`; this.elements.timerBox.classList.toggle("danger", t <= 10.0); },
            syncEssence() { this.elements.essA.textContent = Game.player.essence; this.elements.essB.textContent = Game.player.essence; },
            renderStats() { const p = Game.player, s = p.derived(), panel = this.elements.statPanel; const lines = [`DPS: ${fmt(p.dps(),0)}`, `Physical Damage: ${fmt(s.physicalDamage,2)}`, `Fire Damage: ${fmt(s.fireDamage,2)}`, `Lightning Damage: ${fmt(s.lightningDamage,2)}`, `Cold Damage: ${fmt(s.coldDamage,2)}`, `Attack Speed: ${fmt(s.attackSpeed,2)}/s`, `Maximum Life: ${fmt(s.maxLife,0)}`, `Life Regen: ${fmt(s.lifeRegen,2)}/s`, `Armor: ${fmt(s.armor,0)}`, `Crit Chance: ${fmt(s.critChance,2)}%`, `Crit Damage: ${fmt(s.critDamage,0)}%`, `Move Speed: ${fmt(s.moveSpeed,0)}`, `Magic Find: ${fmt(s.magicFind,0)}%`]; panel.innerHTML = lines.map(l => `<div>${l}</div>`).join(""); },
            // DÜZELTME: Sıralama mantığı, filtreleme yapacak şekilde güncellendi
            renderLoot() {
                const wrap = this.elements.lootGrid; wrap.innerHTML = "";
                const statKey = this.elements.sortStat.value, typeKey = this.elements.sortTypeSel.value, levelFilter = parseInt(this.elements.sortLevel.value) || 0;
                
                let arr = [...Game.player.loot];

                // YENİ: Filtreleme Adımı
                // 1. Seviyeye göre filtrele
                if (levelFilter > 0) {
                    arr = arr.filter(item => item.ilvl === levelFilter);
                }
                // 2. Tipe göre filtrele
                if (typeKey) { // typeKey boş değilse ("All" seçili değilse)
                    arr = arr.filter(item => item.type === typeKey);
                }
                // 3. Stat'a göre filtrele
                if (statKey) { // statKey boş değilse ("-" seçili değilse)
                    arr = arr.filter(item => item.affixes.some(affix => affix.stat === statKey));
                }

                // Filtrelenmiş liste üzerinde sıralama yap
                arr.sort((a, b) => {
                    if (a.locked && !b.locked) return -1;
                    if (b.locked && !a.locked) return 1;
                    
                    // Stat değerine göre büyükten küçüğe sırala
                    if (statKey) {
                        const av = a.affixes.find(x => x.stat === statKey)?.value ?? -Infinity;
                        const bv = b.affixes.find(x => x.stat === statKey)?.value ?? -Infinity;
                        if (bv !== av) return bv - av;
                    }
                    
                    // Nadirliğe göre sırala
                    const rar = RAR_ORDER.indexOf(b.rarity) - RAR_ORDER.indexOf(a.rarity);
                    if (rar !== 0) return rar;

                    // Tipe göre sırala (eğer tip filtresi uygulanmadıysa)
                    if (a.type !== b.type) return a.type.localeCompare(b.type);
                    
                    // Son olarak ID'ye göre sırala
                    return a.id.localeCompare(b.id);
                });

                for (const it of arr) { wrap.appendChild(it.toHTML('loot')); }
                this.refreshHighlights(); this.refreshUpgradeButton();
            },
            renderInventory() {
                const grid = this.elements.invGrid; grid.innerHTML = "";
                const order = ["Helmet", "Chest", "Gloves", "Boots", "Ring1", "Gun", "Belt", "Ring2"];
                const placeholderEmojis = { Helmet: "👑", Chest: "🥻", Gloves: "🧤", Boots: "👞", Ring1: "💍", Gun: "🔫⚔️", Belt: "🩹", Ring2: "💍" };
                for (const t of order) {
                    const slot = document.createElement("div"); slot.className = "slot"; slot.dataset.type = t;
                    const it = Game.player.inv[t];
                    if (it) { slot.appendChild(it.toHTML('inventory')); } else { const ph = document.createElement("div"); ph.className = "placeholder"; ph.textContent = placeholderEmojis[t]; slot.appendChild(ph); }
                    grid.appendChild(slot);
                    slot.addEventListener("dragover", e => e.preventDefault());
                    slot.addEventListener("drop", e => {
                        e.preventDefault(); const data = JSON.parse(e.dataTransfer.getData("text/plain"));
                        if (data.kind === "item") {
                            const item = Game.player.loot.find(it => it.id === data.id) || Object.values(Game.player.inv).find(it => it && it.id === data.id);
                            if (!item) return;
                            let canEquip = false;
                            if (t === 'Gun' && (item.type === 'Gun' || item.type === 'Sword')) { canEquip = true; } else if ((t === 'Ring1' || t === 'Ring2') && item.type === 'Ring') { canEquip = true; } else if (item.type === t) { canEquip = true; }
                            if (!canEquip) return;
                            if (item.ilvl > Game.player.level) { UI.showNotification("Yetersiz Seviye!"); return; }
                            const li = Game.player.loot.findIndex(x => x.id === item.id);
                            if (li >= 0) Game.player.loot.splice(li, 1);
                            const prev = Game.player.inv[t];
                            if (prev) Game.player.loot.unshift(prev);
                            Game.player.inv[t] = item;
                            UI.renderInventory(); UI.renderLoot(); UI.renderStats();
                        }
                    });
                }
                this.refreshHighlights(); this.refreshUpgradeButton();
            },
            getSelectedItem() { const inLoot = Game.player.loot.find(i => i.selected); if (inLoot) return inLoot; for (const k of Object.keys(Game.player.inv)) { const it = Game.player.inv[k]; if (it && it.selected) return it; } return null; },
            refreshUpgradeButton() { const btn = this.elements.upgradeBtn; const it = this.getSelectedItem(); if (!it) { btn.textContent = "Upgrade Selected"; btn.disabled = true; return; } const cost = UPGRADE_COST[it.rarity]; btn.textContent = `Upgrade Selected (${cost} Essence)`; btn.disabled = Game.player.essence < cost; },
            showLevelUp() { const list = this.elements.levelOptions; list.innerHTML = ""; this.elements.levelModal.classList.remove("hidden"); for (const opt of LEVEL_UP_CHOICES) { const b = document.createElement("button"); b.className = "btn"; b.style.background = "#111"; b.style.color = "#fff"; b.style.borderRadius = "10px"; b.style.padding = "12px"; b.textContent = opt.label; b.onclick = () => { opt.apply(Game.player); UI.renderStats(); UI.updateHUD(); UI.hideLevelUp(); Game.pause(false); }; list.appendChild(b); } },
            hideLevelUp() { this.elements.levelModal.classList.add("hidden"); },
            updateButtonStates() { this.elements.nextWave.disabled = Game.justDied; },
            updateBuffs() { const container = document.getElementById("buffContainer"); if (!container) return; const p = Game.player; let hasBuffs = false; container.innerHTML = ""; if (p.frenzyStacks > 0) { hasBuffs = true; const frenzyIcon = document.createElement("div"); frenzyIcon.className = "buff-icon"; frenzyIcon.innerHTML = `🏃 <span>${p.frenzyTimer.toFixed(1)}s (${p.frenzyStacks})</span>`; container.appendChild(frenzyIcon); } const equippedChest = p.inv.Chest; if (equippedChest && equippedChest.uniqueId === 'UNIQUE_CHEST_GUARDIAN') { if (p.guardianShieldActive) { hasBuffs = true; const shieldIcon = document.createElement("div"); shieldIcon.className = "buff-icon"; shieldIcon.innerHTML = `🛡️ <span>${p.guardianShieldTimer.toFixed(1)}s</span>`; container.appendChild(shieldIcon); } else if (p.guardianShieldCooldown > 0) { hasBuffs = true; const cooldownIcon = document.createElement("div"); cooldownIcon.className = "buff-icon cooldown-icon"; cooldownIcon.innerHTML = `⏳ <span>${p.guardianShieldCooldown.toFixed(1)}s</span>`; container.appendChild(cooldownIcon); } } const equippedBoots = p.inv.Boots; if (p.blinkCooldown > 0 && equippedBoots && equippedBoots.uniqueId === 'UNIQUE_BOOTS_BLINK') { hasBuffs = true; const blinkCdIcon = document.createElement("div"); blinkCdIcon.className = "buff-icon cooldown-icon"; blinkCdIcon.innerHTML = `💨 <span>${p.blinkCooldown.toFixed(1)}s</span>`; container.appendChild(blinkCdIcon); } const equippedBelt = p.inv.Belt; if (equippedBelt) { if (equippedBelt.uniqueId === 'UNIQUE_BELT_JUGGERNAUT' && p.juggernautStacks > 0) { hasBuffs = true; const juggernautIcon = document.createElement("div"); juggernautIcon.className = "buff-icon"; juggernautIcon.innerHTML = `🗿 <span>${p.juggernautStacks}</span>`; container.appendChild(juggernautIcon); } if (equippedBelt.uniqueId === 'UNIQUE_BELT_NOVABLAST' && p.novaHitCounter > 0) { hasBuffs = true; const novaIcon = document.createElement("div"); novaIcon.className = "buff-icon"; novaIcon.innerHTML = `💥 <span>${p.novaHitCounter} / 5</span>`; container.appendChild(novaIcon); } } const equippedRing = p.inv.Ring; if (p.greedBuffTimer > 0 && equippedRing && equippedRing.uniqueId === 'UNIQUE_RING_GREED') { hasBuffs = true; const greedIcon = document.createElement("div"); greedIcon.className = "buff-icon"; greedIcon.innerHTML = `💰 <span>${p.greedBuffTimer.toFixed(1)}s</span>`; container.appendChild(greedIcon); } if (hasBuffs) { container.classList.remove("hidden"); } else { container.classList.add("hidden"); } },
            showNotification(message) { const container = document.getElementById("notification-container"); const notif = document.createElement("div"); notif.className = "notification"; notif.textContent = message; container.appendChild(notif); setTimeout(() => notif.remove(), 4000); }
        };
        
        function startGameWithWeapon(weaponType) { const startingWeapon = new Item({ type: weaponType, rarity: 'N', ilvl: 1 }); Game.player.inv.Gun = startingWeapon; Game.startArena(false); }
        document.getElementById("startWithGunBtn").addEventListener("click", () => { startGameWithWeapon('Gun'); });
        document.getElementById("startWithSwordBtn").addEventListener("click", () => { startGameWithWeapon('Sword'); });
        document.getElementById("pauseBtn").addEventListener("click", () => Game.pause());
        document.getElementById("nextWave").addEventListener("click", () => Game.startArena(false));
        document.getElementById("sameWave").addEventListener("click", () => Game.startArena(true));
        document.getElementById("upgradeBtn").addEventListener("click", () => { const it = UI.getSelectedItem(); if (!it) { UI.showNotification("Önce bir item seç."); return; } const cost = UPGRADE_COST[it.rarity]; if (Game.player.essence < cost) { UI.showNotification("Yetersiz essence!"); return; } Game.player.essence -= cost; it.upgrade(); UI.renderLoot(); UI.renderInventory(); UI.renderStats(); UI.syncEssence(); });
        document.getElementById("dismSel").addEventListener("click", () => { const keep = []; let gained = 0; for (const it of Game.player.loot) { if (it.selected && !it.locked) { gained += it.essenceYield(); } else keep.push(it); } Game.player.loot = keep; Game.player.essence += gained; UI.renderLoot(); UI.syncEssence(); });
        document.getElementById("dismAll").addEventListener("click", () => UI.elements.confirmModal.classList.remove("hidden"));
        document.getElementById("confirmNo").addEventListener("click", () => UI.elements.confirmModal.classList.add("hidden"));
        document.getElementById("confirmYes").addEventListener("click", () => { let gained = 0; const keep = []; for (const it of Game.player.loot) { if (it.locked) keep.push(it); else gained += it.essenceYield(); } Game.player.loot = keep; Game.player.essence += gained; UI.renderLoot(); UI.syncEssence(); UI.elements.confirmModal.classList.add("hidden"); });
        document.getElementById("clearSel").addEventListener("click", () => { for (const it of Game.player.loot) it.selected = false; for (const k of Object.keys(Game.player.inv)) { const it = Game.player.inv[k]; if (it) it.selected = false; } UI.renderLoot(); UI.renderInventory(); });
        document.getElementById("sortStat").addEventListener("change", () => UI.renderLoot());
        document.getElementById("sortTypeSel").addEventListener("change", () => UI.renderLoot());
        document.getElementById("sortLevel").addEventListener("input", () => UI.renderLoot());
        document.getElementById("debugItemBtn").addEventListener("click", () => { const playerLevel = Game.player.level; const randomType = choice(TYPE_KEYS); const newItem = new Item({ type: randomType, rarity: 'U', ilvl: -1 }); Game.player.loot.unshift(newItem); UI.renderLoot(); console.log(`DEBUG: Seviye ${playerLevel} bir ${newItem.name} (${randomType}) oluşturuldu.`); });
        const lootWrap = document.querySelector('.lootWrap');
        lootWrap.addEventListener('dragover', (e) => { e.preventDefault(); });
        lootWrap.addEventListener('drop', (e) => {
            e.preventDefault(); const data = JSON.parse(e.dataTransfer.getData("text/plain"));
            if (!data || data.kind !== 'item' || !data.id) return;
            let itemToUnequip = null; let originalSlot = null;
            for (const [slotKey, item] of Object.entries(Game.player.inv)) { if (item && item.id === data.id) { itemToUnequip = item; originalSlot = slotKey; break; } }
            if (itemToUnequip && originalSlot) { Game.player.inv[originalSlot] = null; Game.player.loot.unshift(itemToUnequip); UI.renderInventory(); UI.renderLoot(); UI.renderStats(); }
        });
        window.addEventListener("load", () => { Game.init(); });
    </script>
</body>

</html>